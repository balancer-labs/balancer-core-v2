{
  "language": "Solidity",
  "sources": {
    "contracts/controllers/BasePoolControllerFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../vault/IVault.sol\";\n\nabstract contract BasePoolControllerFactory {\n    using Address for address;\n\n    IVault public immutable vault;\n\n    event ControllerCreated(address indexed controller);\n\n    constructor(IVault _vault) {\n        vault = _vault;\n    }\n\n    /**\n     * @dev Deploys a controller contract defined by `creationCode`. The `salt` value is only used in determining the\n     * resulting controller address. Any value can be passed, but reusing `salt` for a given `creationCode` results in\n     * a revert.\n     *\n     * Before the constructor of the created contract is executed, the factory will register it in the Vault as a\n     * Trusted Operator. This means the contract will be able to pull funds from both User Balance and tokens that have\n     * been granted allowance. As is always the case when dealing with Trusted Operators, the contract should be careful\n     * to authenticate any addresses they use this way.\n     *\n     * The creation code for a Solidity contract can be constructed by concatenating the `creationCode` property of the\n     * contract type with the ABI-encoded constructor arguments. Note that the compiler doesn't perform any type\n     * checking here: all factory-created contracts should be subject to at least basic testing.\n     *\n     * Sample usage using abi.encodePacked to concatenate the `bytes` arrays:\n     *   _create(abi.encodePacked(type(ERC20).creationCode, abi.encode(\"My Token\", \"TKN\", 18)), salt);\n     *\n     * Emits a `ControllerCreated` event.\n     *\n     * Returns the address of the created contract.\n     */\n    function _create(bytes memory creationCode, bytes32 salt) internal returns (address) {\n        address expectedController = Create2.computeAddress(salt, keccak256(creationCode));\n        require(!expectedController.isContract(), \"Salt cannot be reused\");\n\n        vault.reportTrustedOperator(expectedController);\n\n        address controller = Create2.deploy(0, salt, creationCode);\n        assert(controller == expectedController);\n\n        emit ControllerCreated(controller);\n\n        return controller;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint256(_data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/vault/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\npragma solidity ^0.7.1;\n\n// Full external interface for the Vault core contract - no external or public methods exist in the contract that don't\n// override one of these declarations.\ninterface IVault {\n    // User Balance\n\n    /**\n     * @dev Returns `user`'s User Balance for a specific token.\n     */\n    function getUserTokenBalance(address user, IERC20 token) external view returns (uint128);\n\n    /**\n     * @dev Deposits tokens from the caller into `user`'s User Balance.\n     */\n    function deposit(\n        IERC20 token,\n        uint128 amount,\n        address user\n    ) external;\n\n    /**\n     * @dev Withdraws tokens from the caller's User Balance, transferring them to `recipient`. Withdraw protocol fees\n     * are charged by this.\n     */\n    function withdraw(\n        IERC20 token,\n        uint128 amount,\n        address recipient\n    ) external;\n\n    // Operators\n\n    /**\n     * @dev Authorizes `operator` to act as an operator for the caller.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revokes `operator` so that it no longer is an operator for the caller. An account is always its own operator\n     * and cannot revoke itself. Trusted Operators also cannot be revoked.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns true of `operator` is an operator for `user`.\n     */\n    function isOperatorFor(address user, address operator) external view returns (bool);\n\n    /**\n     * @dev Returns the number of operators for `user`. This does not include `user` itself, nor Trusted Operators.\n     */\n    function getUserTotalOperators(address user) external view returns (uint256);\n\n    /**\n     * @dev Returns a partial list of `user`'s operators, starting at index `start`, up to index `end`. This does not\n     * include `user` itself, nor Trusted Operators.\n     *\n     * The ordering of this list may change as operators are authorized and revoked.\n     */\n    function getUserOperators(\n        address user,\n        uint256 start,\n        uint256 end\n    ) external view returns (address[] memory);\n\n    // Trusted operators\n\n    /**\n     @dev Returns the number of Trusted Operators.\n     */\n    function getTotalTrustedOperators() external view returns (uint256);\n\n    /**\n     * @dev Returns a partial list of Trusted Operators, starting at index `start`, up to index `end`.\n     */\n    function getTrustedOperators(uint256 start, uint256 end) external view returns (address[] memory);\n\n    /**\n     * @dev Returns the number of Trusted Operator Reporters.\n     */\n    function getTotalTrustedOperatorReporters() external view returns (uint256);\n\n    /**\n     * @dev Returns a partial list of Trusted Operator Reporters, starting at index `start`, up to index `end`.\n     */\n    function getTrustedOperatorReporters(uint256 start, uint256 end) external view returns (address[] memory);\n\n    /**\n     * @dev Adds `operator` as a Trusted Operator. Can only be called by a Trusted Operator Reporter.\n     */\n    function reportTrustedOperator(address operator) external;\n\n    // Pools\n\n    // There are two variants of Trading Strategies for Pools: Pair Trading Strategies, and Tuple Trading Strategies.\n    // These require different data from the Vault, which is reflected in their differing interfaces\n    // (IPairTradingStrategy and ITupleTradingStrategy, respectively).\n    enum StrategyType { PAIR, TUPLE }\n\n    /**\n     * @dev Creates a new Pool with a Trading Strategy and Trading Strategy Type. The caller of this function becomes\n     * the Pool's controller.\n     *\n     * Returns the created Pool's ID. Also emits a PoolCreated event.\n     */\n    function newPool(address strategy, StrategyType strategyType) external returns (bytes32);\n\n    /**\n     * @dev Emitted when a Pool is created by calling `newPool`. Contains the Pool ID of the created pool.\n     */\n    event PoolCreated(bytes32 poolId);\n\n    // Pool Queries\n\n    /**\n     * @dev Returns the number of Pools.\n     */\n    function getTotalPools() external view returns (uint256);\n\n    /**\n     * @dev Returns a partial list of Pool IDs, starting at index `start`, up to index `end`.\n     */\n    function getPoolIds(uint256 start, uint256 end) external view returns (bytes32[] memory);\n\n    /**\n     * @dev Returns a Pool's controller.\n     */\n    function getPoolController(bytes32 poolId) external view returns (address);\n\n    /**\n     * @dev Returns a Pool's Trading Strategy and Trading Strategy Type.\n     */\n    function getPoolStrategy(bytes32 poolId) external view returns (address, StrategyType);\n\n    /**\n     * @dev Returns all tokens in the Pool (tokens for which the Pool has balance).\n     */\n    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory);\n\n    /**\n     * @dev Returns the Pool's balance of `tokens`. This might be zero if the tokens are not in the Pool.\n     */\n    function getPoolTokenBalances(bytes32 poolId, IERC20[] calldata tokens) external view returns (uint128[] memory);\n\n    function getInvestablePercentage(bytes32 poolId, IERC20 token) external view returns (uint128);\n\n    // Pool Management\n\n    /**\n     * @dev Sets a new controller for a Pool. Can only be called by its current controller.\n     */\n    function setPoolController(bytes32 poolId, address controller) external;\n\n    function authorizePoolInvestmentManager(\n        bytes32 poolId,\n        IERC20 token,\n        address operator\n    ) external;\n\n    function revokePoolInvestmentManager(\n        bytes32 poolId,\n        IERC20 token,\n        address operator\n    ) external;\n\n    /**\n     * @dev Adds liquidity into a Pool. Can only be called by its controller.\n     *\n     * For each token, the Pool's balance will be increased by `totalAmounts[i]`. This is achieved by first transferring\n     * `amountsToTransfer[i]` tokens, and then withdrawing any amount remaining from User Balance. In both cases, the\n     * tokens will come from `from`. `from` must have granted allowance to the Vault, and the caller (Pool controller)\n     * must be an operator for `from`.\n     *\n     * If a token that was not previously in the Pool is granted balance by this function, it will become part of the\n     * Pool. This is the only way tokens can be added to a Pool.\n     */\n    function addLiquidity(\n        bytes32 poolId,\n        address from,\n        IERC20[] calldata tokens,\n        uint128[] calldata totalAmounts,\n        uint128[] calldata amountsToTransfer\n    ) external;\n\n    /**\n     * @dev Removes liquidity from a Pool. Can only be called by its controller.\n     *\n     * For each token, the Pool's balance will be decreased by `totalAmounts[i]`. This is achieved by first transferring\n     * `amountsToTransfer[i]` tokens, and then depositing any amount remaining into User Balance. In both cases, the\n     * tokens are sent to `to`. Withdraw protocol fees are charged over any tokens transferred out.\n     *\n     * If a token that was previously in the Pool has all of its balance removed by this function, it will no longer be\n     * in the Pool. This is the only way tokens can be removed from a Pool.\n     */\n    function removeLiquidity(\n        bytes32 poolId,\n        address to,\n        IERC20[] calldata tokens,\n        uint128[] calldata totalAmounts,\n        uint128[] calldata amountsToTransfer\n    ) external;\n\n    // Trading interface\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. Each swap is validated and executed in order.\n     * However, tokens are only transferred in and out of the Vault (or withdrawn/deposited from User Balance) after all\n     * swaps have been validated and the net token balance change computed. This means it is possible to e.g. under\n     * certain conditions perform arbitrage by swapping with multiple Pools in a way that results in net token movement\n     * out of the Vault (profit), with no tokens being sent in.\n     *\n     * The `diffs` array contains the addresses of all tokens involved in the swaps, along with how many tokens the\n     * caller expects to transfer into the Vault for each. Any tokens due to the Vault not included in this amount will\n     * be withdrawn from User Balance.\n     *\n     * The `swaps` array contains the information about each individual swaps. All swaps consist of a Pool receiving\n     * some amount of one of its tokens (`tokenIn`), and sending some amount of another one of its tokens (`tokenOut`).\n     * A swap cannot cause `tokenOut` to be fully drained. The Pools' Trading Strategies will validate each swap,\n     * possibly charging a swap fee on the amount going in. If so, the protocol will then charge the protocol swap fee\n     * to the Pool's own swap fee.\n     *\n     * Funds will be received according to the data in `fundsIn`, and sent according to `fundsOut`.\n     */\n    function batchSwapGivenIn(\n        SwapIn[] calldata swaps,\n        IERC20[] memory tokens,\n        FundManagement calldata funds\n    ) external returns (int256[] memory vaultDeltas);\n\n    function batchSwapGivenOut(\n        SwapOut[] calldata swaps,\n        IERC20[] memory tokens,\n        FundManagement calldata funds\n    ) external returns (int256[] memory vaultDeltas);\n\n    // batchSwap helper data structures\n\n    // A batched swap is made up of a number of Swaps. Each swap indicates a token balance increasing (tokenIn) and one\n    // decreasing (tokenOut) in a pool.\n    // Indexes instead of token addresses to not perform lookup in the tokens array.\n    struct SwapIn {\n        bytes32 poolId;\n        uint128 tokenInIndex;\n        uint128 tokenOutIndex;\n        uint128 amountIn;\n        bytes userData;\n    }\n\n    struct SwapOut {\n        bytes32 poolId;\n        uint128 tokenInIndex;\n        uint128 tokenOutIndex;\n        uint128 amountOut;\n        bytes userData;\n    }\n\n    // Funds in are received by `IERC20.transferFrom` from `withdrawFrom`. If received funds are not enough, they are\n    // withdrawn from withdrawFrom's User Balance.\n    // In any case, the caller must be an operator for withdrawFrom.\n    // Funds out are deposited to recipient's User Balance, or transferred out if transferToRecipient is true.\n    struct FundManagement {\n        address sender;\n        address recipient;\n        bool withdrawFromUserBalance;\n        bool depositToUserBalance;\n    }\n\n    // Flash Loan interface\n    function flashLoan(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        bytes memory _params //TODO check for reentrancy\n    ) external;\n\n    // Investment interface\n    function setInvestablePercentage(\n        bytes32 poolId,\n        IERC20 token,\n        uint128 percentage\n    ) external;\n\n    function updateInvested(\n        bytes32 poolId,\n        IERC20 token,\n        uint128 amountInvested\n    ) external;\n\n    // Unaccounted-for Tokens\n\n    /**\n     * @dev Returns the number of unaccounted-for tokens for `token`.\n     */\n    function getTotalUnaccountedForTokens(IERC20 token) external view returns (uint256);\n\n    // Admin Controls\n\n    /**\n     * @dev Authorizes `reporter` to call `reportTrustedOperator`. This is typically called on factory contracts. Can\n     * only be called by the admin.\n     */\n    function authorizeTrustedOperatorReporter(address reporter) external;\n\n    /**\n     * @dev Transfers to `recipient` the requested amounts of unnaccounted-for tokens. Can only be called by the admin.\n     */\n    function claimUnaccountedForTokens(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        address recipient\n    ) external;\n\n    // Missing here: setting protocol fees, changing admin\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/test/MockPoolControllerFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"../vault/IVault.sol\";\n\nimport \"../controllers/BasePoolControllerFactory.sol\";\n\ncontract MockPoolController {\n    IVault public vault;\n\n    constructor(IVault _vault) {\n        vault = _vault;\n\n        require(_vault.isOperatorFor(address(0), address(this)), \"Not a Trusted Operator during construction\");\n    }\n}\n\ncontract MockPoolControllerFactory is BasePoolControllerFactory {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(IVault _vault) BasePoolControllerFactory(_vault) {}\n\n    function create(bytes32 salt) external returns (address) {\n        return _create(abi.encodePacked(type(MockPoolController).creationCode, abi.encode(vault)), salt);\n    }\n}\n"
    },
    "contracts/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"./IVault.sol\";\nimport \"./Settings.sol\";\nimport \"./VaultAccounting.sol\";\nimport \"./UserBalance.sol\";\nimport \"./PoolRegistry.sol\";\nimport \"./FlashLoanProvider.sol\";\nimport \"./Settings.sol\";\nimport \"./Swaps.sol\";\nimport \"./Admin.sol\";\n\n// solhint-disable no-empty-blocks\n\ncontract Vault is IVault, Settings, VaultAccounting, UserBalance, PoolRegistry, FlashLoanProvider, Swaps, Admin {\n    constructor(address _admin) Admin(_admin) {}\n}\n"
    },
    "contracts/vault/Settings.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"../math/FixedPoint.sol\";\nimport \"./IVault.sol\";\n\n// solhint-disable var-name-mixedcase\n\nabstract contract Settings is IVault {\n    using FixedPoint for uint256;\n    using FixedPoint for uint128;\n\n    // Protocol fees: these are charged as unaccounted for tokens, and can therefore be claimed and distributed by the\n    // system admin.\n\n    // The withdraw fee is charged whenever tokens exit the vault (except in the case of swaps), and is a\n    // percentage of the tokens exiting\n    uint128 private _protocolWithdrawFee;\n\n    // The swap fee is charged whenever a swap occurs, and is a percentage of the fee charged by the trading strategy.\n    // The Vault relies on the trading strategy being honest and reporting the actuall fee it charged.\n    uint128 private _protocolSwapFee;\n\n    uint128 private immutable _MAX_PROTOCOL_WITHDRAW_FEE = FixedPoint.ONE.mul128(2).div128(100); // 0.02 (2%)\n\n    // The flash loan fee is charged whenever a flash loan occurs, and is a percentage of the tokens lent\n    uint256 private _protocolFlashLoanFee;\n\n    uint128 private immutable _MAX_PROTOCOL_SWAP_FEE = FixedPoint.ONE.mul128(50).div128(100); // 0.5 (50%)\n\n    uint256 private immutable _MAX_PROTOCOL_FLASH_LOAN_FEE = FixedPoint.ONE.mul128(50).div128(100); // 0.5 (50%)\n\n    function _setProtocolWithdrawFee(uint128 newFee) internal {\n        require(newFee <= _MAX_PROTOCOL_WITHDRAW_FEE, \"Withdraw fee too high\");\n        _protocolWithdrawFee = newFee;\n    }\n\n    function protocolWithdrawFee() public view returns (uint128) {\n        return _protocolWithdrawFee;\n    }\n\n    function _applyProtocolWithdrawFee(uint128 amount) internal view returns (uint128) {\n        uint128 fee = amount.mul128(_protocolWithdrawFee);\n        return amount.sub128(fee);\n    }\n\n    function _setProtocolSwapFee(uint128 newFee) internal {\n        require(newFee <= _MAX_PROTOCOL_SWAP_FEE, \"Swap fee too high\");\n        _protocolSwapFee = newFee;\n    }\n\n    function protocolSwapFee() public view returns (uint128) {\n        return _protocolSwapFee;\n    }\n\n    function _calculateProtocolSwapFee(uint128 swapFeeAmount) internal view returns (uint128) {\n        return swapFeeAmount.mul128(_protocolSwapFee);\n    }\n\n    function _setProtocolFlashLoanFee(uint256 newFee) internal {\n        require(newFee <= _MAX_PROTOCOL_FLASH_LOAN_FEE, \"FlashLoan fee too high\");\n        _protocolFlashLoanFee = newFee;\n    }\n\n    function protocolFlashLoanFee() public view returns (uint256) {\n        return _protocolFlashLoanFee;\n    }\n\n    function _calculateProtocolFlashLoanFee(uint256 swapFeeAmount) internal view returns (uint256) {\n        return swapFeeAmount.mul(_protocolFlashLoanFee);\n    }\n}\n"
    },
    "contracts/vault/VaultAccounting.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nimport \"../math/FixedPoint.sol\";\n\nimport \"./IVault.sol\";\nimport \"./Settings.sol\";\n\nlibrary BalanceLib {\n    using FixedPoint for uint128;\n\n    // This data structure is used to represent a token's balance for a Pool. 'cash' is how many tokens the Pool has\n    // sitting inside of the Vault. 'total' is always larger or equal to 'cash', and represents the Pool's total token\n    // balance, including tokens that are *not* inside of the Vault.\n    //\n    // Cash and total are updated in concordance whenever tokens are added/removed from a Pool, except when interacting\n    // with the Pool's Investment Manager. The Investment Manager updates the new 'total' value (according to its own)\n    // internal logic, which the Vault uses when validating swaps with the Pool's Trading Strategy, as well as returns\n    // profits by returning invested 'cash'.\n    //\n    // The Vault disallows the Pool's 'cash' ever becoming negative, in other words, it can never use any tokens that\n    // are not inside of the Vault.\n    struct Balance {\n        uint128 cash;\n        uint128 total;\n    }\n\n    /**\n     * @dev The number of invested assets. This is simply the difference between 'total' and 'cash' - the Vault has no\n     * insights into how the assets are used by the Investment Manager.\n     */\n    function invested(Balance memory self) internal pure returns (uint128) {\n        return self.total - self.cash;\n    }\n\n    /**\n     * @dev Increases a Pool's balance. Called when tokens are added to the Pool (except from the Investment Manager).\n     */\n    function increase(Balance memory self, uint128 amount) internal pure returns (Balance memory) {\n        return Balance({ cash: self.cash.add128(amount), total: self.total.add128(amount) });\n    }\n\n    /**\n     * @dev Decreases a Pool's balance. Called when tokens are removed from the Pool (except to the Investment Manager).\n     */\n    function decrease(Balance memory self, uint128 amount) internal pure returns (Balance memory) {\n        return Balance({ cash: self.cash.sub128(amount), total: self.total.sub128(amount) });\n    }\n}\n\nabstract contract VaultAccounting is IVault, Settings {\n    using BalanceLib for BalanceLib.Balance;\n    using FixedPoint for uint256;\n    using FixedPoint for uint128;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    // The Vault's accounted-for balance for each token. This should always be equal to the sum of all User Balance\n    // tokens, plus all 'cash' of all Pools.\n    // TODO: make this uint128 and not Balance, since it consists exclusively of 'cash'.\n    mapping(IERC20 => BalanceLib.Balance) internal _vaultTokenBalance; // token -> vault balance\n\n    function getTotalUnaccountedForTokens(IERC20 token) public view override returns (uint256) {\n        uint256 totalBalance = token.balanceOf(address(this));\n        assert(totalBalance >= _vaultTokenBalance[token].cash);\n\n        return totalBalance - _vaultTokenBalance[token].cash;\n    }\n\n    /**\n     * @dev Transfers tokens into the Vault from `from`. The caller must verify that this action was authorized by\n     * `from` (typically by the entry-point function being called by an operator for `from`).\n     *\n     * The number of tokens received are measured as a delta, by calling `IERC20.balanceOf` before and after the\n     * transfer. This means tokens with a transfer fee are supported. The number of tokens received is returned.\n     */\n    function _pullTokens(\n        IERC20 token,\n        address from,\n        uint128 amount\n    ) internal returns (uint128) {\n        if (amount == 0) {\n            return 0;\n        }\n\n        uint256 currentBalance = token.balanceOf(address(this));\n\n        token.safeTransferFrom(from, address(this), amount);\n\n        uint256 newBalance = token.balanceOf(address(this));\n\n        uint128 received = newBalance.sub(currentBalance).toUint128();\n\n        _vaultTokenBalance[token] = _vaultTokenBalance[token].increase(received);\n\n        return received;\n    }\n\n    /**\n     * @dev Transfers tokens from the Vault to `to`. If `chargeFee` is true, a withdrawal fee will be charged as\n     * unaccounted-for tokens.\n     */\n    function _pushTokens(\n        IERC20 token,\n        address to,\n        uint128 amount,\n        bool chargeFee\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        _vaultTokenBalance[token] = _vaultTokenBalance[token].decrease(amount);\n\n        uint128 amountToSend = chargeFee ? _applyProtocolWithdrawFee(amount) : amount;\n\n        token.safeTransfer(to, amountToSend);\n    }\n}\n"
    },
    "contracts/vault/UserBalance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"hardhat/console.sol\";\n\nimport \"../vendor/EnumerableSet.sol\";\n\nimport \"./IVault.sol\";\nimport \"./VaultAccounting.sol\";\n\nimport \"../math/FixedPoint.sol\";\n\nabstract contract UserBalance is IVault, VaultAccounting {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using FixedPoint for uint128;\n\n    mapping(address => mapping(IERC20 => uint128)) internal _userTokenBalance; // user -> token -> user balance\n\n    // Operators are allowed to use a user's tokens in a swap\n    mapping(address => EnumerableSet.AddressSet) private _userOperators;\n\n    // Trusted operators are operators for all users, without needing to be authorized. Trusted operators cannot be\n    // revoked.\n    EnumerableSet.AddressSet private _trustedOperators;\n\n    // Trusted operators reporters can report new trusted operators\n    EnumerableSet.AddressSet internal _trustedOperatorReporters;\n\n    event Deposited(address indexed depositor, address indexed user, IERC20 indexed token, uint128 amount);\n\n    event Withdrawn(address indexed user, address indexed recipient, IERC20 indexed token, uint128 amount);\n\n    event AuthorizedOperator(address indexed user, address indexed operator);\n    event RevokedOperator(address indexed user, address indexed operator);\n\n    event AuthorizedTrustedOperator(address indexed operator);\n\n    function getUserTokenBalance(address user, IERC20 token) public view override returns (uint128) {\n        return _userTokenBalance[user][token];\n    }\n\n    function deposit(\n        IERC20 token,\n        uint128 amount,\n        address user\n    ) external override {\n        // Pulling from the sender - no need to check for operators\n        uint128 received = _pullTokens(token, msg.sender, amount);\n\n        // TODO: check overflow\n        _userTokenBalance[user][token] = _userTokenBalance[user][token].add128(received);\n        emit Deposited(msg.sender, user, token, received);\n    }\n\n    function withdraw(\n        IERC20 token,\n        uint128 amount,\n        address recipient\n    ) external override {\n        require(_userTokenBalance[msg.sender][token] >= amount, \"Vault: withdraw amount exceeds balance\");\n\n        _userTokenBalance[msg.sender][token] -= amount;\n        _pushTokens(token, recipient, amount, true);\n\n        emit Withdrawn(msg.sender, recipient, token, amount);\n    }\n\n    function authorizeOperator(address operator) external override {\n        if (_userOperators[msg.sender].add(operator)) {\n            emit AuthorizedOperator(msg.sender, operator);\n        }\n    }\n\n    function revokeOperator(address operator) external override {\n        if (_userOperators[msg.sender].remove(operator)) {\n            emit RevokedOperator(msg.sender, operator);\n        }\n    }\n\n    function isOperatorFor(address user, address operator) public view override returns (bool) {\n        return (user == operator) || _trustedOperators.contains(operator) || _userOperators[user].contains(operator);\n    }\n\n    function getUserTotalOperators(address user) external view override returns (uint256) {\n        return _userOperators[user].length();\n    }\n\n    function getUserOperators(\n        address user,\n        uint256 start,\n        uint256 end\n    ) external view override returns (address[] memory) {\n        require((end >= start) && (end - start) <= _userOperators[user].length(), \"Bad indices\");\n\n        // Ideally we'd use a native implemenation: see\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2390\n        address[] memory operators = new address[](end - start);\n\n        for (uint256 i = 0; i < operators.length; ++i) {\n            operators[i] = _userOperators[user].at(i + start);\n        }\n\n        return operators;\n    }\n\n    function getTotalTrustedOperators() external view override returns (uint256) {\n        return _trustedOperators.length();\n    }\n\n    function getTrustedOperators(uint256 start, uint256 end) external view override returns (address[] memory) {\n        require((end >= start) && (end - start) <= _trustedOperators.length(), \"Bad indices\");\n\n        // Ideally we'd use a native implemenation: see\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2390\n        address[] memory operators = new address[](end - start);\n\n        for (uint256 i = 0; i < operators.length; ++i) {\n            operators[i] = _trustedOperators.at(i + start);\n        }\n\n        return operators;\n    }\n\n    function getTotalTrustedOperatorReporters() external view override returns (uint256) {\n        return _trustedOperatorReporters.length();\n    }\n\n    function getTrustedOperatorReporters(uint256 start, uint256 end) external view override returns (address[] memory) {\n        require((end >= start) && (end - start) <= _trustedOperatorReporters.length(), \"Bad indices\");\n\n        // Ideally we'd use a native implemenation: see\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2390\n        address[] memory operatorReporters = new address[](end - start);\n\n        for (uint256 i = 0; i < operatorReporters.length; ++i) {\n            operatorReporters[i] = _trustedOperatorReporters.at(i + start);\n        }\n\n        return operatorReporters;\n    }\n\n    function reportTrustedOperator(address operator) external override {\n        require(_trustedOperatorReporters.contains(msg.sender), \"Caller is not trusted operator reporter\");\n\n        if (_trustedOperators.add(operator)) {\n            emit AuthorizedTrustedOperator(operator);\n        }\n    }\n}\n"
    },
    "contracts/vault/PoolRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../vendor/EnumerableSet.sol\";\n\nimport \"./IVault.sol\";\nimport \"./VaultAccounting.sol\";\nimport \"./UserBalance.sol\";\nimport \"../investmentManagers/IInvestmentManager.sol\";\n\nabstract contract PoolRegistry is ReentrancyGuard, IVault, VaultAccounting, UserBalance {\n    using EnumerableSet for EnumerableSet.BytesSet;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    using BalanceLib for BalanceLib.Balance;\n\n    using FixedPoint for uint128;\n\n    struct PoolStrategy {\n        address strategy;\n        StrategyType strategyType;\n    }\n\n    // Set with all pools in the system\n    // TODO do we need this? can pools be deleted? if not, an array should be good enough\n    EnumerableSet.BytesSet internal _pools;\n\n    // The controller of a pool is the only account that can:\n    //  - change the controller\n    //  - change the trading strategy\n    //  - add tokens\n    //  - remove tokens\n    // The creator of a pool is the initial controller.\n    mapping(bytes32 => address) internal _poolController;\n\n    // Set with all tokens in a pool\n    mapping(bytes32 => EnumerableSet.AddressSet) internal _poolTokens;\n\n    // Tokens in a pool have non-zero balances, which can be used as a shortcut to check\n    // at once if a) a pool exists and b) a token is in that pool.\n    mapping(bytes32 => mapping(IERC20 => BalanceLib.Balance)) internal _poolTokenBalance;\n    // poolid => token => pool balance\n\n    modifier withExistingPool(bytes32 poolId) {\n        require(_pools.contains(poolId), \"Inexistent pool\");\n        _;\n    }\n\n    // investable percentage per token\n    mapping(bytes32 => mapping(IERC20 => uint128)) internal _investablePercentage;\n\n    // operators are allowed to use a pools tokens for an investment\n    mapping(bytes32 => mapping(IERC20 => address)) private _poolInvestmentManagers;\n\n    event AuthorizedPoolInvestmentManager(bytes32 indexed poolId, IERC20 indexed token, address indexed operator);\n    event RevokedPoolInvestmentManager(bytes32 indexed poolId, IERC20 indexed token, address indexed operator);\n\n    modifier onlyPoolController(bytes32 poolId) {\n        require(_poolController[poolId] == msg.sender, \"Caller is not the pool controller\");\n        _;\n    }\n\n    function toPoolId(\n        address strategy,\n        uint16 strategyType,\n        uint32 poolIndex\n    ) public pure returns (bytes32) {\n        uint256 serialized;\n        serialized |= uint256(poolIndex) << (22 * 8);\n        serialized |= uint256(strategyType) << (20 * 8);\n        serialized |= uint256(strategy);\n        return bytes32(serialized);\n    }\n\n    function fromPoolId(bytes32 serialized) public pure returns (address strategy, StrategyType strategyType) {\n        //|| 6 bytes empty | 4 bytes count of pools | 2 bytes strategyType | 20 bytes address ||\n        strategy = address(uint256(serialized) & (2**(20 * 8) - 1));\n        strategyType = StrategyType(uint256(serialized >> (20 * 8)) & (2**(2 * 8) - 1));\n    }\n\n    function newPool(address strategy, StrategyType strategyType) external override returns (bytes32) {\n        bytes32 poolId = toPoolId(strategy, uint16(strategyType), uint32(_pools.length()));\n\n        require(!_pools.contains(poolId), \"Pool ID already exists\");\n        require(strategy != address(0), \"Strategy must be set\");\n\n        _pools.add(poolId);\n        _poolController[poolId] = msg.sender;\n\n        emit PoolCreated(poolId);\n\n        return poolId;\n    }\n\n    function getTotalPools() external view override returns (uint256) {\n        return _pools.length();\n    }\n\n    function getPoolIds(uint256 start, uint256 end) external view override returns (bytes32[] memory) {\n        require((end >= start) && (end - start) <= _pools.length(), \"Bad indices\");\n\n        bytes32[] memory poolIds = new bytes32[](end - start);\n        for (uint256 i = 0; i < poolIds.length; ++i) {\n            poolIds[i] = _pools.at(i + start);\n        }\n\n        return poolIds;\n    }\n\n    function getPoolTokens(bytes32 poolId) external view override withExistingPool(poolId) returns (IERC20[] memory) {\n        IERC20[] memory tokens = new IERC20[](_poolTokens[poolId].length());\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            tokens[i] = IERC20(_poolTokens[poolId].at(i));\n        }\n\n        return tokens;\n    }\n\n    function getPoolTokenBalances(bytes32 poolId, IERC20[] calldata tokens)\n        external\n        view\n        override\n        withExistingPool(poolId)\n        returns (uint128[] memory)\n    {\n        uint128[] memory balances = new uint128[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            balances[i] = _poolTokenBalance[poolId][tokens[i]].total;\n        }\n\n        return balances;\n    }\n\n    function getPoolController(bytes32 poolId) external view override withExistingPool(poolId) returns (address) {\n        return _poolController[poolId];\n    }\n\n    function getPoolStrategy(bytes32 poolId)\n        external\n        view\n        override\n        withExistingPool(poolId)\n        returns (address, StrategyType)\n    {\n        (address strategy, StrategyType strategyType) = fromPoolId(poolId);\n        return (strategy, strategyType);\n    }\n\n    function setPoolController(bytes32 poolId, address controller)\n        external\n        override\n        nonReentrant\n        withExistingPool(poolId)\n        onlyPoolController(poolId)\n    {\n        _poolController[poolId] = controller;\n    }\n\n    function addLiquidity(\n        bytes32 poolId,\n        address from,\n        IERC20[] calldata tokens,\n        uint128[] calldata totalAmounts,\n        uint128[] calldata amountsToTransfer\n    ) external override withExistingPool(poolId) onlyPoolController(poolId) {\n        require(tokens.length == totalAmounts.length, \"Tokens and total amounts length mismatch\");\n\n        require(totalAmounts.length == amountsToTransfer.length, \"Amount arrays length mismatch\");\n\n        require(isOperatorFor(from, msg.sender), \"Caller is not operator\");\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            {\n                // scope for received - avoids 'stack too deep' error\n\n                uint128 received = _pullTokens(tokens[i], from, amountsToTransfer[i]);\n\n                {\n                    // scope for amountFromuserBalance - avoids 'stack too deep' error\n\n                    // This checks totalAmounts[i] >= amountsTransferred[i] (assuming amountsTransferred[i] >= received)\n                    uint128 amountFromUserBalance = totalAmounts[i].sub128(received);\n\n                    if (amountFromUserBalance > 0) {\n                        _userTokenBalance[from][tokens[i]] = _userTokenBalance[from][tokens[i]].sub128(\n                            amountFromUserBalance\n                        );\n                    }\n                }\n            }\n\n            if (totalAmounts[i] > 0) {\n                BalanceLib.Balance memory currentBalance = _poolTokenBalance[poolId][tokens[i]];\n\n                if (currentBalance.total == 0) {\n                    // No tokens with zero balance should ever be in the _poolTokens set\n                    assert(_poolTokens[poolId].add(address(tokens[i])));\n                }\n\n                _poolTokenBalance[poolId][tokens[i]] = _poolTokenBalance[poolId][tokens[i]].increase(totalAmounts[i]);\n            }\n        }\n    }\n\n    function removeLiquidity(\n        bytes32 poolId,\n        address to,\n        IERC20[] calldata tokens,\n        uint128[] calldata totalAmounts,\n        uint128[] calldata amountsToTransfer\n    ) external override withExistingPool(poolId) onlyPoolController(poolId) {\n        require(tokens.length == totalAmounts.length, \"Tokens and total amounts length mismatch\");\n\n        require(totalAmounts.length == amountsToTransfer.length, \"Amount arrays length mismatch\");\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            require(_poolTokens[poolId].contains(address(tokens[i])), \"Token not in pool\");\n\n            // This asserts  totalAmounts[i] >= amountsToTransfer[i]\n            uint128 amountToUserBalance = totalAmounts[i].sub128(amountsToTransfer[i]);\n\n            _pushTokens(tokens[i], to, amountsToTransfer[i], true);\n\n            if (amountToUserBalance > 0) {\n                _userTokenBalance[to][tokens[i]] = _userTokenBalance[to][tokens[i]].add128(amountToUserBalance);\n            }\n\n            _poolTokenBalance[poolId][tokens[i]] = _poolTokenBalance[poolId][tokens[i]].decrease(totalAmounts[i]);\n\n            if (_poolTokenBalance[poolId][tokens[i]].total == 0) {\n                _poolTokens[poolId].remove(address(tokens[i]));\n            }\n        }\n    }\n\n    function getInvestablePercentage(bytes32 poolId, IERC20 token)\n        external\n        view\n        override\n        withExistingPool(poolId)\n        returns (uint128)\n    {\n        return _investablePercentage[poolId][token];\n    }\n\n    function setInvestablePercentage(\n        bytes32 poolId,\n        IERC20 token,\n        uint128 percentage\n    ) external override nonReentrant withExistingPool(poolId) onlyPoolController(poolId) {\n        require(percentage <= FixedPoint.ONE, \"Percentage must be between 0 and 100%\");\n        _investablePercentage[poolId][token] = percentage;\n    }\n\n    function authorizePoolInvestmentManager(\n        bytes32 poolId,\n        IERC20 token,\n        address operator\n    ) external override onlyPoolController(poolId) {\n        require(\n            _poolInvestmentManagers[poolId][token] == address(0) ||\n                _poolTokenBalance[poolId][token].cash == _poolTokenBalance[poolId][token].total,\n            \"Cannot set a new investment manager with outstanding investment\"\n        );\n        _poolInvestmentManagers[poolId][token] = operator;\n        emit AuthorizedPoolInvestmentManager(poolId, token, operator);\n    }\n\n    function revokePoolInvestmentManager(\n        bytes32 poolId,\n        IERC20 token,\n        address operator\n    ) external override onlyPoolController(poolId) {\n        require(\n            _poolInvestmentManagers[poolId][token] != address(0) &&\n                _poolTokenBalance[poolId][token].cash == _poolTokenBalance[poolId][token].total,\n            \"Cannot remove an investment manager with outstanding investment\"\n        );\n\n        delete _poolInvestmentManagers[poolId][token];\n        emit RevokedPoolInvestmentManager(poolId, token, operator);\n    }\n\n    modifier onlyPoolInvestmentManager(\n        bytes32 poolId,\n        IERC20 token,\n        address operator\n    ) {\n        require(isPoolInvestmentManager(poolId, token, operator), \"Only pool investment operator\");\n        _;\n    }\n\n    function isPoolInvestmentManager(\n        bytes32 poolId,\n        IERC20 token,\n        address operator\n    ) public view returns (bool) {\n        return _poolInvestmentManagers[poolId][token] == operator;\n    }\n\n    // Investments\n    // how the investment manager receives more tokens to invest\n    // callable by anyone\n    function investPoolBalance(\n        bytes32 poolId,\n        IERC20 token,\n        address investmentManager,\n        uint128 amountToInvest // must be less than total allowed\n    ) public onlyPoolInvestmentManager(poolId, token, investmentManager) {\n        uint128 targetUtilization = _investablePercentage[poolId][token];\n        uint128 targetInvestableAmount = _poolTokenBalance[poolId][token].total.mul128(targetUtilization);\n\n        uint128 investedAmount = _poolTokenBalance[poolId][token].invested();\n\n        require(\n            investedAmount.add128(amountToInvest) <= targetInvestableAmount,\n            \"over investment amount - cannot invest\"\n        );\n\n        _poolTokenBalance[poolId][token].cash = _poolTokenBalance[poolId][token].cash.sub128(amountToInvest);\n\n        _pushTokens(token, investmentManager, amountToInvest, false);\n        IInvestmentManager(investmentManager).recordPoolInvestment(poolId, amountToInvest);\n    }\n\n    function divestPoolBalance(\n        bytes32 poolId,\n        IERC20 token,\n        address investmentManager,\n        uint128 amountToDivest // must be less than total allowed\n    ) public onlyPoolInvestmentManager(poolId, token, investmentManager) {\n        uint128 targetUtilization = _investablePercentage[poolId][token];\n        uint128 targetInvestableAmount = _poolTokenBalance[poolId][token].total.mul128(targetUtilization);\n        uint128 investedAmount = _poolTokenBalance[poolId][token].invested();\n        require(\n            investedAmount.sub128(amountToDivest) >= targetInvestableAmount,\n            \"under investment amount - cannot divest\"\n        );\n\n        _poolTokenBalance[poolId][token].cash = _poolTokenBalance[poolId][token].cash.add128(amountToDivest);\n\n        // think about what happens with tokens that charge a transfer fee\n        _pullTokens(token, investmentManager, amountToDivest);\n        IInvestmentManager(investmentManager).recordPoolDivestment(poolId, amountToDivest);\n    }\n\n    function rebalancePoolInvestment(\n        bytes32 poolId,\n        IERC20 token,\n        address investmentManager\n    ) public onlyPoolInvestmentManager(poolId, token, investmentManager) {\n        uint128 targetUtilization = _investablePercentage[poolId][token];\n        uint128 targetInvestableAmount = _poolTokenBalance[poolId][token].total.mul128(targetUtilization);\n        uint128 investedAmount = _poolTokenBalance[poolId][token].invested();\n\n        if (targetInvestableAmount > investedAmount) {\n            uint128 amountToInvest = targetInvestableAmount.sub128(investedAmount);\n            _poolTokenBalance[poolId][token].cash = _poolTokenBalance[poolId][token].cash.sub128(amountToInvest);\n\n            _pushTokens(token, investmentManager, amountToInvest, false);\n            IInvestmentManager(investmentManager).recordPoolInvestment(poolId, amountToInvest);\n        } else if (targetInvestableAmount < investedAmount) {\n            uint128 amountToDivest = investedAmount.sub128(targetInvestableAmount);\n            _poolTokenBalance[poolId][token].cash = _poolTokenBalance[poolId][token].cash.add128(amountToDivest);\n\n            // think about what happens with tokens that charge a transfer fee\n            _pullTokens(token, investmentManager, amountToDivest);\n            IInvestmentManager(investmentManager).recordPoolDivestment(poolId, amountToDivest);\n        } else {\n            revert(\"Pool balance is already balanced between cash and investment\");\n        }\n    }\n\n    // how the investment manager updates the value of invested tokens to the curves knowledge\n    function updateInvested(\n        bytes32 poolId,\n        IERC20 token,\n        uint128 amountInvested\n    ) public override onlyPoolInvestmentManager(poolId, token, msg.sender) {\n        _poolTokenBalance[poolId][token].total = amountInvested.add128(_poolTokenBalance[poolId][token].cash);\n    }\n}\n"
    },
    "contracts/vault/FlashLoanProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// This flash loan provider was based on the Aave protocol's open source\n// implementation and terminology and interfaces are intentionally kept\n// similar\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"../math/FixedPoint.sol\";\nimport \"./IFlashLoanReceiver.sol\";\nimport \"./IVault.sol\";\nimport \"./Settings.sol\";\n\nabstract contract FlashLoanProvider is IVault, Settings {\n    using FixedPoint for uint256;\n\n    /**\n     * @dev emitted when a flashloan is executed\n     * @param _target the address of the flashLoanReceiver\n     * @param _token the address of the ERC20 token\n     * @param _amount the amount requested\n     * @param _fee the fee on the amount\n     * @param _timestamp the timestamp of the action\n     **/\n    event FlashLoan(address indexed _target, address indexed _token, uint256 _amount, uint256 _fee, uint256 _timestamp);\n\n    /**\n     * @dev allows smartcontracts to access the liquidity of the vault within one transaction,\n     * as long as the amount taken plus a fee is returned. NOTE There are security concerns for developers of flashloan\n     * receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param _receiver The address of the contract receiving the funds. The receiver should implement the\n     * IFlashLoanReceiver interface.\n     * @param _token the address of the principal ERC-20 token\n     * @param _amount the amount requested for this flashloan\n     **/\n    function flashLoan(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        bytes memory _params //TODO check for reentrancy\n    ) external override {\n        //check that the token has enough available liquidity\n        uint256 availableLiquidityBefore = IERC20(_token).balanceOf(address(this));\n\n        require(availableLiquidityBefore >= _amount, \"There is not enough liquidity available to borrow\");\n\n        //calculate fee on amount\n        uint256 amountFee = _calculateProtocolFlashLoanFee(_amount);\n        require(amountFee > 0, \"The requested amount is too small for a flashLoan.\");\n\n        //get the FlashLoanReceiver instance\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);\n\n        address payable userPayable = address(uint160(_receiver));\n\n        //transfer funds to the receiver\n        IERC20(_token).transfer(userPayable, _amount);\n\n        //execute action of the receiver\n        receiver.executeOperation(_token, _amount, amountFee, _params);\n\n        //check that the actual balance of the core contract includes the returned amount\n        uint256 availableLiquidityAfter = IERC20(_token).balanceOf(address(this));\n\n        require(\n            availableLiquidityAfter == availableLiquidityBefore.add(amountFee),\n            \"The actual balance of the protocol is inconsistent\"\n        );\n\n        emit FlashLoan(_receiver, _token, _amount, amountFee, block.timestamp);\n    }\n}\n"
    },
    "contracts/vault/Swaps.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../vendor/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"../math/FixedPoint.sol\";\n\nimport \"../strategies/ITradingStrategy.sol\";\nimport \"../strategies/IPairTradingStrategy.sol\";\nimport \"../strategies/ITupleTradingStrategy.sol\";\n\nimport \"./IVault.sol\";\nimport \"./VaultAccounting.sol\";\nimport \"./PoolRegistry.sol\";\nimport \"./UserBalance.sol\";\n\nabstract contract Swaps is ReentrancyGuard, IVault, VaultAccounting, UserBalance, PoolRegistry {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using BalanceLib for BalanceLib.Balance;\n    using FixedPoint for uint256;\n    using FixedPoint for uint128;\n    using SafeCast for uint256;\n    using SafeCast for uint128;\n\n    // Despite the external API having two separate functions for given in and given out, internally their are handled\n    // together to avoid unnecessary code duplication. This enum indicates which kind of swap we're processing.\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n    // This struct is identical in layout to SwapIn and SwapOut, except the 'amountIn/Out' field is named 'amount'.\n    struct SwapInternal {\n        bytes32 poolId;\n        uint128 tokenInIndex;\n        uint128 tokenOutIndex;\n        uint128 amount;\n        bytes userData;\n    }\n\n    function batchSwapGivenIn(\n        SwapIn[] memory swaps,\n        IERC20[] memory tokens,\n        FundManagement memory funds\n    ) external override returns (int256[] memory) {\n        return _batchSwap(_toInternalSwap(swaps), tokens, funds, SwapKind.GIVEN_IN);\n    }\n\n    function batchSwapGivenOut(\n        SwapOut[] memory swaps,\n        IERC20[] memory tokens,\n        FundManagement memory funds\n    ) external override returns (int256[] memory) {\n        return _batchSwap(_toInternalSwap(swaps), tokens, funds, SwapKind.GIVEN_OUT);\n    }\n\n    // We use inline assembly to cast from the external struct types to the internal one. This doesn't trigger any\n    // conversions or runtime analysis: it is just coercing the type system to reinterpret the data as another type.\n\n    function _toInternalSwap(SwapIn[] memory swapsIn) private pure returns (SwapInternal[] memory swapsInternal) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            swapsInternal := swapsIn\n        }\n    }\n\n    function _toInternalSwap(SwapOut[] memory swapsOut) private pure returns (SwapInternal[] memory swapsInternal) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            swapsInternal := swapsOut\n        }\n    }\n\n    // This struct is identical in layout to QuoteRequestGivenIn and QuoteRequestGivenIn from ITradingStrategy, except\n    // the 'amountIn/Out' is named 'amount'.\n    struct QuoteRequestInternal {\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint128 amount;\n        bytes32 poolId;\n        address from;\n        address to;\n        bytes userData;\n    }\n\n    // We use inline assembly to cast from the internal struct type to the external ones, depending on the swap kind.\n    // This doesn't trigger any conversions or runtime analysis: it is just coercing the type system to reinterpret the\n    // data as another type.\n\n    function _toQuoteGivenIn(QuoteRequestInternal memory requestInternal)\n        private\n        pure\n        returns (ITradingStrategy.QuoteRequestGivenIn memory requestGivenIn)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            requestGivenIn := requestInternal\n        }\n    }\n\n    function _toQuoteGivenOut(QuoteRequestInternal memory requestInternal)\n        private\n        pure\n        returns (ITradingStrategy.QuoteRequestGivenOut memory requestGivenOut)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            requestGivenOut := requestInternal\n        }\n    }\n\n    function _batchSwap(\n        SwapInternal[] memory swaps,\n        IERC20[] memory tokens,\n        FundManagement memory funds,\n        SwapKind kind\n    ) private nonReentrant returns (int256[] memory) {\n        //TODO: avoid reentrancy\n\n        // Any net token amount going into the Vault will be taken from `funds.sender`, so they must have\n        // approved the caller to use their funds.\n        require(isOperatorFor(funds.sender, msg.sender), \"Caller is not operator\");\n\n        int256[] memory tokenDeltas = new int256[](tokens.length);\n\n        // Contains the swap protocol fees charged for each token\n        uint128[] memory tokenSwapProtocolFees = new uint128[](tokens.length);\n\n        LastSwapData memory previous;\n        SwapInternal memory swap;\n\n        // Steps 1, 2 & 3:\n        //  - check swaps are valid\n        //  - update pool balances\n        //  - accumulate token diffs\n        for (uint256 i = 0; i < swaps.length; ++i) {\n            swap = swaps[i];\n\n            (uint128 amountIn, uint128 amountOut, uint128 protocolSwapFee) = _swapWithPool(\n                tokens,\n                swap,\n                funds.sender,\n                funds.recipient,\n                previous,\n                kind\n            );\n\n            // 3: Accumulate token diffs\n            tokenDeltas[swap.tokenInIndex] += amountIn;\n            tokenDeltas[swap.tokenOutIndex] -= amountOut;\n\n            // 3b: Accumulate token swap protocol fees\n            tokenSwapProtocolFees[swap.tokenInIndex] = tokenSwapProtocolFees[swap.tokenInIndex].add128(protocolSwapFee);\n        }\n\n        // Step 4: Receive tokens due to the Vault, withdrawing missing amounts from User Balance\n        // Step 5: Send tokens due to the recipient\n        // Step 6: Deduct swap protocol swap fees from the Vault's balance - this makes them unaccounted-for\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n\n            if (tokenDeltas[i] > 0) {\n                uint128 toReceive = uint128(tokenDeltas[i]);\n\n                if (funds.withdrawFromUserBalance) {\n                    uint128 toWithdraw = uint128(Math.min(_userTokenBalance[funds.sender][token], toReceive));\n\n                    _userTokenBalance[funds.sender][token] -= toWithdraw;\n                    toReceive -= toWithdraw;\n                }\n\n                uint128 received = _pullTokens(token, funds.sender, toReceive);\n                require(received == toReceive, \"Not enough tokens received\");\n            } else {\n                // Make delta positive\n                uint128 toSend = uint128(-tokenDeltas[i]);\n\n                if (funds.depositToUserBalance) {\n                    // Deposit tokens to the recipient's User Balance - the Vault's balance doesn't change\n                    _userTokenBalance[funds.recipient][token] = _userTokenBalance[funds.recipient][token].add128(\n                        toSend\n                    );\n                } else {\n                    // Actually transfer the tokens to the recipient\n                    _pushTokens(token, funds.recipient, toSend, false);\n                }\n            }\n\n            _vaultTokenBalance[token] = _vaultTokenBalance[token].decrease(tokenSwapProtocolFees[i]);\n        }\n\n        return tokenDeltas;\n    }\n\n    // This struct helps implement the multihop logic: if the amount given is not provided for a swap, then the token\n    // given must match the previous token quoted, and the previous amount quoted becomes the new amount given.\n    // For swaps of kind given in, amount in and token in are given, while amount out and token out quoted.\n    // For swaps of kind given out, amount out and token out are given, while amount in and token in quoted.\n    struct LastSwapData {\n        IERC20 tokenQuoted;\n        uint128 amountQuoted;\n    }\n\n    function _tokenGiven(\n        SwapKind kind,\n        IERC20 tokenIn,\n        IERC20 tokenOut\n    ) private pure returns (IERC20) {\n        return kind == SwapKind.GIVEN_IN ? tokenIn : tokenOut;\n    }\n\n    function _tokenQuoted(\n        SwapKind kind,\n        IERC20 tokenIn,\n        IERC20 tokenOut\n    ) private pure returns (IERC20) {\n        return kind == SwapKind.GIVEN_IN ? tokenOut : tokenIn;\n    }\n\n    function _getAmounts(\n        SwapKind kind,\n        uint128 amountGiven,\n        uint128 amountQuoted\n    ) private pure returns (uint128 amountIn, uint128 amountOut) {\n        if (kind == SwapKind.GIVEN_IN) {\n            (amountIn, amountOut) = (amountGiven, amountQuoted);\n        } else {\n            (amountIn, amountOut) = (amountQuoted, amountGiven);\n        }\n    }\n\n    function _swapWithPool(\n        IERC20[] memory tokens,\n        SwapInternal memory swap,\n        address from,\n        address to,\n        LastSwapData memory previous,\n        SwapKind kind\n    )\n        private\n        returns (\n            uint128 amountIn,\n            uint128 amountOut,\n            uint128 protocolSwapFee\n        )\n    {\n        IERC20 tokenIn = tokens[swap.tokenInIndex];\n        IERC20 tokenOut = tokens[swap.tokenOutIndex];\n        require(tokenIn != tokenOut, \"Swap for same token\");\n\n        uint128 amountGiven = swap.amount;\n        if (amountGiven == 0) {\n            require(previous.tokenQuoted != IERC20(0), \"Unknown amount in on first swap\");\n            require(previous.tokenQuoted == _tokenGiven(kind, tokenIn, tokenOut), \"Misconstructed multihop swap\");\n\n            amountGiven = previous.amountQuoted;\n        }\n\n        QuoteRequestInternal memory request = QuoteRequestInternal({\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            amount: amountGiven,\n            poolId: swap.poolId,\n            from: from,\n            to: to,\n            userData: swap.userData\n        });\n\n        uint128 amountQuoted;\n        (amountQuoted, protocolSwapFee) = _processQuoteRequest(request, kind);\n\n        previous.tokenQuoted = _tokenQuoted(kind, tokenIn, tokenOut);\n        previous.amountQuoted = amountQuoted;\n\n        (amountIn, amountOut) = _getAmounts(kind, amountGiven, amountQuoted);\n    }\n\n    function _processQuoteRequest(QuoteRequestInternal memory request, SwapKind kind)\n        private\n        returns (uint128 amountQuoted, uint128 protocolSwapFee)\n    {\n        (address strategy, StrategyType strategyType) = fromPoolId(request.poolId);\n\n        BalanceLib.Balance memory tokenInFinalBalance;\n        BalanceLib.Balance memory tokenOutFinalBalance;\n\n        if (strategyType == StrategyType.PAIR) {\n            (\n                tokenInFinalBalance,\n                tokenOutFinalBalance,\n                amountQuoted,\n                protocolSwapFee\n            ) = _processPairTradingStrategyQuoteRequest(request, IPairTradingStrategy(strategy), kind);\n        } else if (strategyType == StrategyType.TUPLE) {\n            (\n                tokenInFinalBalance,\n                tokenOutFinalBalance,\n                amountQuoted,\n                protocolSwapFee\n            ) = _processTupleTradingStrategyQuoteRequest(request, ITupleTradingStrategy(strategy), kind);\n        } else {\n            revert(\"Unknown strategy type\");\n        }\n\n        // 2: Update Pool balances - these have been deducted the swap protocol fees\n        _poolTokenBalance[request.poolId][request.tokenIn] = tokenInFinalBalance;\n        _poolTokenBalance[request.poolId][request.tokenOut] = tokenOutFinalBalance;\n    }\n\n    function _processPairTradingStrategyQuoteRequest(\n        QuoteRequestInternal memory request,\n        IPairTradingStrategy strategy,\n        SwapKind kind\n    )\n        private\n        returns (\n            BalanceLib.Balance memory poolTokenInBalance,\n            BalanceLib.Balance memory poolTokenOutBalance,\n            uint128,\n            uint128 protocolSwapFee\n        )\n    {\n        poolTokenInBalance = _poolTokenBalance[request.poolId][request.tokenIn];\n        require(poolTokenInBalance.total > 0, \"Token A not in pool\");\n\n        poolTokenOutBalance = _poolTokenBalance[request.poolId][request.tokenOut];\n        require(poolTokenOutBalance.total > 0, \"Token B not in pool\");\n\n        if (kind == SwapKind.GIVEN_IN) {\n            (uint128 amountOut, uint128 tokenInFeeAmount) = strategy.quoteOutGivenIn(\n                _toQuoteGivenIn(request),\n                poolTokenInBalance.total,\n                poolTokenOutBalance.total\n            );\n\n            protocolSwapFee = _calculateProtocolSwapFee(tokenInFeeAmount);\n\n            return (\n                poolTokenInBalance.increase(request.amount.sub128(protocolSwapFee)),\n                poolTokenOutBalance.decrease(amountOut),\n                amountOut,\n                protocolSwapFee\n            );\n        } else {\n            (uint128 amountIn, uint128 tokenInFeeAmount) = strategy.quoteInGivenOut(\n                _toQuoteGivenOut(request),\n                poolTokenInBalance.total,\n                poolTokenOutBalance.total\n            );\n\n            protocolSwapFee = _calculateProtocolSwapFee(tokenInFeeAmount);\n\n            return (\n                poolTokenInBalance.increase(amountIn.sub128(protocolSwapFee)),\n                poolTokenOutBalance.decrease(request.amount),\n                amountIn,\n                protocolSwapFee\n            );\n        }\n    }\n\n    // TODO: Temporary struct to workaround stack-too-deep: remove once #73 is implemented\n    struct Helper {\n        uint256 indexIn;\n        uint256 indexOut;\n    }\n\n    function _processTupleTradingStrategyQuoteRequest(\n        QuoteRequestInternal memory request,\n        ITupleTradingStrategy strategy,\n        SwapKind kind\n    )\n        private\n        returns (\n            BalanceLib.Balance memory poolTokenInBalance,\n            BalanceLib.Balance memory poolTokenOutBalance,\n            uint128,\n            uint128 protocolSwapFee\n        )\n    {\n        uint128[] memory currentBalances = new uint128[](_poolTokens[request.poolId].length());\n\n        Helper memory helper;\n\n        for (uint256 i = 0; i < _poolTokens[request.poolId].length(); i++) {\n            IERC20 token = IERC20(_poolTokens[request.poolId].at(i));\n            BalanceLib.Balance memory balance = _poolTokenBalance[request.poolId][token];\n\n            currentBalances[i] = balance.total;\n\n            if (token == request.tokenIn) {\n                helper.indexIn = i;\n                poolTokenInBalance = balance;\n            } else if (token == request.tokenOut) {\n                helper.indexOut = i;\n                poolTokenOutBalance = balance;\n            }\n        }\n\n        require(poolTokenInBalance.total > 0, \"Token A not in pool\");\n        require(poolTokenOutBalance.total > 0, \"Token B not in pool\");\n\n        if (kind == SwapKind.GIVEN_IN) {\n            (uint128 amountOut, uint128 tokenInFeeAmount) = strategy.quoteOutGivenIn(\n                _toQuoteGivenIn(request),\n                currentBalances,\n                helper.indexIn,\n                helper.indexOut\n            );\n\n            protocolSwapFee = _calculateProtocolSwapFee(tokenInFeeAmount);\n\n            return (\n                poolTokenInBalance.increase(request.amount.sub128(protocolSwapFee)),\n                poolTokenOutBalance.decrease(amountOut),\n                amountOut,\n                protocolSwapFee\n            );\n        } else {\n            (uint128 amountIn, uint128 tokenInFeeAmount) = strategy.quoteInGivenOut(\n                _toQuoteGivenOut(request),\n                currentBalances,\n                helper.indexIn,\n                helper.indexOut\n            );\n\n            protocolSwapFee = _calculateProtocolSwapFee(tokenInFeeAmount);\n\n            return (\n                poolTokenInBalance.increase(amountIn.sub128(protocolSwapFee)),\n                poolTokenOutBalance.decrease(request.amount),\n                amountIn,\n                protocolSwapFee\n            );\n        }\n    }\n}\n"
    },
    "contracts/vault/Admin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"../math/FixedPoint.sol\";\n\nimport \"../vendor/EnumerableSet.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./IVault.sol\";\nimport \"./Settings.sol\";\nimport \"./UserBalance.sol\";\n\nabstract contract Admin is IVault, Settings, UserBalance {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeERC20 for IERC20;\n\n    address private _admin;\n\n    constructor(address admin) {\n        _admin = admin;\n    }\n\n    function admin() public view returns (address) {\n        return _admin;\n    }\n\n    function transferAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"Caller is not the admin\");\n\n        _admin = newAdmin;\n    }\n\n    function setProtocolWithdrawFee(uint128 fee) external {\n        require(msg.sender == _admin, \"Caller is not the admin\");\n        _setProtocolWithdrawFee(fee);\n    }\n\n    function setProtocolSwapFee(uint128 fee) external {\n        require(msg.sender == _admin, \"Caller is not the admin\");\n        _setProtocolSwapFee(fee);\n    }\n\n    function setProtocolFlashLoanFee(uint128 fee) external {\n        require(msg.sender == _admin, \"Caller is not the admin\");\n        _setProtocolFlashLoanFee(fee);\n    }\n\n    function authorizeTrustedOperatorReporter(address reporter) external override {\n        require(msg.sender == _admin, \"Caller is not the admin\");\n\n        _trustedOperatorReporters.add(reporter);\n    }\n\n    function claimUnaccountedForTokens(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        address recipient\n    ) external override {\n        require(msg.sender == _admin, \"Caller is not the admin\");\n        require(tokens.length == amounts.length, \"Tokens and amounts length mismatch\");\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            uint256 totalUnaccountedFor = getTotalUnaccountedForTokens(tokens[i]);\n            require(totalUnaccountedFor >= amounts[i], \"Insufficient unaccounted for tokens\");\n\n            tokens[i].safeTransfer(recipient, amounts[i]);\n        }\n    }\n}\n"
    },
    "contracts/math/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\n\n/* solhint-disable private-vars-leading-underscore */\n\nlibrary FixedPoint {\n    uint128 internal constant ONE = 10**18; // 18 decimal places\n\n    uint256 internal constant MIN_POW_BASE = 1 wei;\n    uint256 internal constant MAX_POW_BASE = (2 * ONE) - 1 wei;\n    uint256 internal constant POW_PRECISION = ONE / 10**10;\n\n    function btoi(uint256 a) internal pure returns (uint256) {\n        return a / ONE;\n    }\n\n    function floor(uint256 a) internal pure returns (uint256) {\n        return btoi(a) * ONE;\n    }\n\n    function abs(int256 a) internal pure returns (uint256) {\n        if (a > 0) {\n            return uint256(a);\n        } else {\n            // TODO: check valid\n            return uint256(-a);\n        }\n    }\n\n    function abs128(int128 a) internal pure returns (uint128) {\n        if (a > 0) {\n            return uint128(a);\n        } else {\n            // TODO: check valid\n            return uint128(-a);\n        }\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function add128(uint128 a, uint128 b) internal pure returns (uint128) {\n        uint128 c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (uint256 c, bool flag) = subSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function subSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function sub128(uint128 a, uint128 b) internal pure returns (uint128) {\n        (uint128 c, bool flag) = subSign128(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function subSign128(uint128 a, uint128 b) internal pure returns (uint128, bool) {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint256 c1 = c0 + (ONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint256 c2 = c1 / ONE;\n        return c2;\n    }\n\n    function mul128(uint128 a, uint128 b) internal pure returns (uint128) {\n        uint128 c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint128 c1 = c0 + (ONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint128 c2 = c1 / ONE;\n        return c2;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint256 c0 = a * ONE;\n        require(a == 0 || c0 / a == ONE, \"ERR_DIV_INTERNAL\"); // mul overflow\n        uint256 c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  add require\n        uint256 c2 = c1 / b;\n        return c2;\n    }\n\n    function div128(uint128 a, uint128 b) internal pure returns (uint128) {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint128 c0 = a * ONE;\n        require(a == 0 || c0 / a == ONE, \"ERR_DIV_INTERNAL\"); // mul overflow\n        uint128 c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  add require\n        uint128 c2 = c1 / b;\n        return c2;\n    }\n\n    // DSMath.wpow\n    function powi(uint256 a, uint256 n) internal pure returns (uint256) {\n        uint256 z = n % 2 != 0 ? a : ONE;\n\n        for (n /= 2; n != 0; n /= 2) {\n            a = mul(a, a);\n\n            if (n % 2 != 0) {\n                z = mul(z, a);\n            }\n        }\n        return z;\n    }\n\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n    // Use `powi` for `b^e` and `powK` for k iterations\n    // of approximation of b^0.w\n    function pow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        require(base >= MIN_POW_BASE, \"ERR_POW_BASE_TOO_LOW\");\n        require(base <= MAX_POW_BASE, \"ERR_POW_BASE_TOO_HIGH\");\n\n        uint256 whole = floor(exp);\n        uint256 remain = sub(exp, whole);\n\n        uint256 wholePow = powi(base, btoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint256 partialResult = powApprox(base, remain, POW_PRECISION);\n        return mul(wholePow, partialResult);\n    }\n\n    function powApprox(\n        uint256 base,\n        uint256 exp,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        // term 0:\n        uint256 a = exp;\n        (uint256 x, bool xneg) = subSign(base, ONE);\n        uint256 term = ONE;\n        uint256 sum = term;\n        bool negative = false;\n\n        // term(k) = numer / denom\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\n        // continue until term is less than precision\n        for (uint256 i = 1; term >= precision; i++) {\n            uint256 bigK = i * ONE;\n            (uint256 c, bool cneg) = subSign(a, sub(bigK, ONE));\n            term = mul(term, mul(c, x));\n            term = div(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = sub(sum, term);\n            } else {\n                sum = add(sum, term);\n            }\n        }\n\n        return sum;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.8.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(byte)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/vendor/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// Based on the EnumerableSet library from OpenZeppelin contracts, altered to include\n// a set for bytes32.\n// See https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2395\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`BytesSet`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // BytesSet\n\n    struct BytesSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(BytesSet storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(BytesSet storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(BytesSet storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(BytesSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(BytesSet storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/investmentManagers/IInvestmentManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface IInvestmentManager {\n    function recordPoolInvestment(bytes32 poolId, uint128 tokensIn) external;\n\n    function recordPoolDivestment(bytes32 poolId, uint128 tokensIn) external;\n}\n"
    },
    "contracts/vault/IFlashLoanReceiver.sol": {
      "content": "pragma solidity ^0.7.1;\n\n/**\n * @title IFlashLoanReceiver interface\n * @notice Interface for a recipient of a flash loan\n * @author Aave\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n **/\ninterface IFlashLoanReceiver {\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/strategies/ITradingStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ITradingStrategy {\n    // TODO: outdated docs, fix\n    // This data structure represents a two tokens swap and is used by strategies for trade validation.\n    // `from` is the origin address where the entering funds are coming from\n    // `to` is the destination address where exiting funds are going to.\n    // `tokenIn` and 'tokenOut' are the token increasing in funds and the token decreasing respectively.\n    // `amountIn` and `amountOut` are the amount increased by `tokenIn`\n    // and the amount decreased by `tokenOut`respectively.\n    // `userData` is any extra data that the swap caller wants to send to the strategy to validate the swap.\n    struct QuoteRequestGivenIn {\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint128 amountIn;\n        // Misc data\n        bytes32 poolId;\n        address from;\n        address to;\n        bytes userData;\n    }\n\n    struct QuoteRequestGivenOut {\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint128 amountOut;\n        // Misc data\n        bytes32 poolId;\n        address from;\n        address to;\n        bytes userData;\n    }\n}\n"
    },
    "contracts/strategies/IPairTradingStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"./ITradingStrategy.sol\";\n\ninterface IPairTradingStrategy is ITradingStrategy {\n    function quoteOutGivenIn(\n        QuoteRequestGivenIn calldata request,\n        uint128 currentBalanceTokenIn,\n        uint128 currentBalanceTokenOut\n    ) external returns (uint128 amountOut, uint128 amountInFees);\n\n    function quoteInGivenOut(\n        QuoteRequestGivenOut calldata request,\n        uint128 currentBalanceTokenIn,\n        uint128 currentBalanceTokenOut\n    ) external returns (uint128 amountIn, uint128 amountInFees);\n}\n"
    },
    "contracts/strategies/ITupleTradingStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"./ITradingStrategy.sol\";\n\ninterface ITupleTradingStrategy is ITradingStrategy {\n    function quoteOutGivenIn(\n        QuoteRequestGivenIn calldata request,\n        uint128[] calldata balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) external returns (uint128 amountOut, uint128 amountInFees);\n\n    function quoteInGivenOut(\n        QuoteRequestGivenOut calldata request,\n        uint128[] calldata balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) external returns (uint128 amountIn, uint128 amountInFees);\n}\n"
    },
    "contracts/investmentManagers/InvestmentManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"../vault/IVault.sol\";\nimport \"./IInvestmentManager.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../math/FixedPoint.sol\";\n\n// solhint-disable var-name-mixedcase\n\ncontract InvestmentManager is IInvestmentManager {\n    using FixedPoint for uint256;\n    using FixedPoint for uint128;\n\n    // an only-increasing accumulator that is like an exchange rate between the accounting units and the\n    // asset invested\n    // Increases as returns accrue, ie if it started at 100 and the investment returned 5% it would now be 105\n    uint128 public presentValue;\n    IERC20 internal _token;\n\n    uint128 public cash; // how much sits in cash - ideally 0\n    uint128 public total; // total\n\n    struct Investment {\n        uint128 amount; // amount added at time t\n        uint128 asOf; // relative value of amount added at time t\n    }\n\n    // pool investments\n    mapping(bytes32 => Investment) public investments;\n\n    // Investment and Divestment into this contract\n    event Invested(bytes32 poolId, uint128 amount);\n    event Divested(bytes32 poolId, uint128 amount);\n\n    IVault internal immutable _vault;\n\n    constructor(IVault vault, address token) {\n        _vault = vault;\n        _token = IERC20(token);\n        presentValue = FixedPoint.ONE;\n    }\n\n    // allows the vault to do anything with the tokens held as cash\n    function initialize() public virtual {\n        // grant allowance to vault\n\n        uint256 MAX_INT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        _token.approve(address(_vault), MAX_INT);\n    }\n\n    modifier onlyVault {\n        require(msg.sender == address(_vault), \"callback only callable by vault\");\n        _;\n    }\n\n    // Callback after the vault sends tokens\n    function recordPoolInvestment(bytes32 poolId, uint128 tokensIn) external override onlyVault {\n        uint128 amountIn = tokensIn.div128(presentValue);\n\n        if (investments[poolId].amount == 0) {\n            investments[poolId] = Investment({ amount: amountIn, asOf: presentValue });\n        } else {\n            // when there is already an investment we need to scale it to current values\n            uint128 currentValue = investments[poolId].amount.mul128(presentValue).div128(investments[poolId].asOf);\n            investments[poolId].amount = amountIn + currentValue;\n            investments[poolId].asOf = presentValue;\n        }\n        total = total.add128(amountIn);\n        cash = cash.add128(amountIn);\n\n        emit Invested(poolId, amountIn);\n    }\n\n    // Callback after the vault pulls tokens\n    function recordPoolDivestment(bytes32 poolId, uint128 tokensOut) external override onlyVault {\n        uint128 amountOut = tokensOut.div128(presentValue);\n\n        require(investments[poolId].amount != 0, \"There must be an existing investment to divest\");\n        // when there is already an investment we need to scale it to current values\n        uint128 currentValue = investments[poolId].amount.mul128(presentValue).div128(investments[poolId].asOf);\n        investments[poolId].amount = currentValue.sub128(amountOut);\n        investments[poolId].asOf = presentValue;\n\n        cash = cash.sub128(amountOut);\n        total = total.sub128(amountOut);\n        emit Divested(poolId, amountOut);\n    }\n\n    // Update the vaults notion of a pool's total token balance\n    function updateInvested(bytes32 poolId) external {\n        require(investments[poolId].amount != 0, \"No investment was made for this pool yet\");\n\n        uint128 currentValue = investments[poolId].amount.mul128(presentValue).div128(investments[poolId].asOf);\n        _vault.updateInvested(poolId, _token, currentValue);\n    }\n}\n"
    },
    "contracts/test/MockInvestmentManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nimport \"../vault/IVault.sol\";\nimport \"../investmentManagers/InvestmentManager.sol\";\nimport \"../math/FixedPoint.sol\";\n\n// solhint-disable no-empty-blocks\n\ncontract MockInvestmentManager is InvestmentManager {\n    using FixedPoint for uint128;\n    using SafeCast for uint256;\n\n    constructor(IVault vault, address token) InvestmentManager(vault, token) {}\n\n    // Mock function to simulate investment returns\n    function mockIncreasePresentValue(uint128 amount) external {\n        presentValue = presentValue.add128(amount);\n    }\n\n    // Example functions that an InvestmentManager would use\n    // to get a return on their capital\n\n    // transfers capital out, for invesment\n    function sow(uint128 amount) public {\n        // TODO depends on implementation\n        cash -= amount;\n\n        // Do something with the tokens\n        // ie. IERC20(token).transfer(somewhere);\n    }\n\n    // calls capital back in from investments\n    function reap(uint128 amount) public {\n        // TODO depends on implementation\n\n        // Turn investment into cash\n        // uint128 unaccountedForProfit = IERC20(_token).balanceOf(address(this)).toUint128().sub128(cash);\n        //presentValue = presentValue.mul128(total.add128(amount)).div128(total);\n\n        cash += amount;\n    }\n}\n"
    },
    "contracts/strategies/FlattenedTradingStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nimport \"./ITupleTradingStrategy.sol\";\nimport \"./lib/Stable.sol\";\nimport \"./StrategyFee.sol\";\n\ncontract FlattenedTradingStrategy is ITupleTradingStrategy, StrategyFee, Stable {\n    using SafeCast for uint256;\n    using FixedPoint for uint256;\n    using FixedPoint for uint128;\n\n    uint128 private immutable _amp;\n    uint256 private immutable _swapFee;\n\n    constructor(uint128 amp, uint256 swapFee) {\n        require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\n        require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\n        _swapFee = swapFee;\n        _amp = amp;\n    }\n\n    //Because it is not possible to overriding external calldata, function is public and balances are in memory\n    function quoteOutGivenIn(\n        ITradingStrategy.QuoteRequestGivenIn calldata request,\n        uint128[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) external view override returns (uint128, uint128) {\n        // Substract fee\n        uint128 amountInFees = request.amountIn.mul(_swapFee).toUint128();\n        uint128 adjustedIn = request.amountIn.sub128(amountInFees);\n\n        uint128 maximumAmountOut = _outGivenIn(_amp, balances, indexIn, indexOut, adjustedIn);\n\n        return (maximumAmountOut, amountInFees);\n    }\n\n    function quoteInGivenOut(\n        ITradingStrategy.QuoteRequestGivenOut calldata request,\n        uint128[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) external view override returns (uint128, uint128) {\n        uint128 minimumAmountIn = _inGivenOut(_amp, balances, indexIn, indexOut, request.amountOut);\n\n        // Add fee\n        uint128 adjustedIn = minimumAmountIn.div128(FixedPoint.ONE.sub128(_swapFee.toUint128()));\n        uint128 amountInFees = adjustedIn.sub128(minimumAmountIn);\n\n        return (adjustedIn, amountInFees);\n    }\n\n    function getAmp() external view returns (uint128) {\n        return _amp;\n    }\n\n    function getSwapFee() external view override returns (uint256) {\n        return _swapFee;\n    }\n}\n"
    },
    "contracts/strategies/lib/Stable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\n\nimport \"hardhat/console.sol\";\n\nimport \"../../math/FixedPoint.sol\";\n\n// This is a contract to emulate file-level functions. Convert to a library\n// after the migration to solc v0.7.1.\n\n// solhint-disable private-vars-leading-underscore\n// solhint-disable var-name-mixedcase\n\ncontract Stable {\n    int256 internal constant PRECISION = 100000000000000;\n\n    struct Data {\n        int256 amp;\n        int256 invariant;\n        int256 sum;\n        int256 nn;\n        int256 prod;\n    }\n\n    function _approximateAmount(Data memory data, uint128 approxAmount) private pure returns (uint128) {\n        uint128 newApproxAmount;\n        int256 c1 = data.amp * data.sum + ((FixedPoint.ONE / data.nn) - data.amp) * data.invariant;\n        int256 c2 = (data.invariant * data.invariant * data.invariant) / (data.nn * data.nn * data.prod);\n        for (int256 i = 0; i < 255; i++) {\n            int256 f1 = data.amp * approxAmount * approxAmount + c1 * approxAmount - c2 * FixedPoint.ONE;\n            int256 f2 = c1 + 2 * data.amp * approxAmount;\n            newApproxAmount = uint128(approxAmount - (f1 / f2));\n            if (newApproxAmount > approxAmount) {\n                if ((newApproxAmount - approxAmount) <= PRECISION) {\n                    break;\n                }\n            } else if ((newApproxAmount - approxAmount) <= PRECISION) {\n                break;\n            }\n            approxAmount = newApproxAmount;\n        }\n        return newApproxAmount;\n    }\n\n    function _getDataOutGivenIn(\n        int256 amp,\n        uint128[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint128 tokenAmountIn\n    ) private pure returns (Data memory) {\n        int256 invariant = _invariant(amp, balances);\n        int256 sum = 0;\n        int256 prod = FixedPoint.ONE;\n        uint256 n = balances.length;\n        int256 nn = 1;\n        for (uint256 i = 0; i < n; i++) {\n            if (i != tokenIndexOut) {\n                if (i == tokenIndexIn) {\n                    sum = sum + balances[i] + tokenAmountIn;\n                    prod = (prod * (balances[i] + tokenAmountIn)) / FixedPoint.ONE;\n                } else {\n                    sum = sum + balances[i];\n                    prod = (prod * balances[i]) / FixedPoint.ONE;\n                }\n            }\n            nn = nn * int256(n);\n        }\n        return Data({ amp: amp, invariant: invariant, sum: sum, nn: nn, prod: prod });\n    }\n\n    function _getDataInGivenOut(\n        int256 amp,\n        uint128[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint128 tokenAmountOut\n    ) private pure returns (Data memory) {\n        int256 invariant = _invariant(amp, balances);\n        int256 sum = 0;\n        int256 prod = FixedPoint.ONE;\n        uint256 n = balances.length;\n        int256 nn = 1;\n        for (uint256 i = 0; i < n; i++) {\n            if (i != tokenIndexIn) {\n                if (i == tokenIndexOut) {\n                    sum = sum + balances[i] - tokenAmountOut;\n                    prod = (prod * (balances[i] - tokenAmountOut)) / FixedPoint.ONE;\n                } else {\n                    sum = sum + balances[i];\n                    prod = (prod * balances[i]) / FixedPoint.ONE;\n                }\n            }\n            nn = nn * int256(n);\n        }\n        return Data({ amp: amp, invariant: invariant, sum: sum, nn: nn, prod: prod });\n    }\n\n    function _outGivenIn(\n        int256 amp,\n        uint128[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint128 tokenAmountIn\n    ) internal pure returns (uint128) {\n        Data memory data = _getDataOutGivenIn(amp, balances, tokenIndexIn, tokenIndexOut, tokenAmountIn);\n        uint128 approxTokenAmountOut = balances[tokenIndexOut] - tokenAmountIn;\n        return balances[tokenIndexOut] - _approximateAmount(data, approxTokenAmountOut);\n    }\n\n    function _inGivenOut(\n        int256 amp,\n        uint128[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint128 tokenAmountOut\n    ) internal pure returns (uint128) {\n        Data memory data = _getDataInGivenOut(amp, balances, tokenIndexIn, tokenIndexOut, tokenAmountOut);\n        uint128 approxTokenAmountIn = balances[tokenIndexIn] + tokenAmountOut;\n        return _approximateAmount(data, approxTokenAmountIn) - balances[tokenIndexIn];\n    }\n\n    function _invariant(int256 amp, uint128[] memory balances) internal pure returns (int256) {\n        int256 sum = 0;\n        int256 prod = FixedPoint.ONE;\n        uint256 n = balances.length;\n        int256 nn = 1;\n        for (uint256 i = 0; i < n; i++) {\n            sum = sum + balances[i];\n            prod = (prod * balances[i]) / FixedPoint.ONE;\n            nn = nn * int256(n);\n        }\n        int256 invariant = sum;\n        int256 newInvariant;\n        int256 c2 = amp - FixedPoint.ONE / nn;\n        int256 c1 = (nn * nn * prod);\n        for (int256 i = 0; i < 255; i++) {\n            int256 f1 = (c2 * invariant + (((invariant * invariant) / c1) * invariant) - amp * sum) / FixedPoint.ONE;\n            int256 f2 = (c2 * FixedPoint.ONE + 3 * ((invariant * FixedPoint.ONE) / c1) * invariant) / FixedPoint.ONE;\n            newInvariant =\n                invariant -\n                (2 * f1 * f2 * FixedPoint.ONE) /\n                (2 * f2 * f2 + f1 * 6 * ((invariant * FixedPoint.ONE) / c1));\n            if (newInvariant > invariant) {\n                if ((newInvariant - invariant) <= PRECISION) {\n                    return newInvariant;\n                }\n            } else if ((invariant - newInvariant) <= PRECISION) {\n                return newInvariant;\n            }\n            invariant = newInvariant;\n        }\n        return newInvariant;\n    }\n}\n"
    },
    "contracts/strategies/StrategyFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\n\nabstract contract StrategyFee {\n    uint256 public constant MIN_FEE = 0;\n    //uint256 public constant MIN_FEE = 10**12; //0.000001%\n    uint256 public constant MAX_FEE = 10**17; //0.1%\n\n    /**\n     * @dev Returns the swap fee for the Trading Strategy.\n     */\n    function getSwapFee() external view virtual returns (uint256);\n}\n"
    },
    "contracts/strategies/CWPTradingStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nimport \"./IPairTradingStrategy.sol\";\nimport \"./lib/WeightedProduct.sol\";\nimport \"./StrategyFee.sol\";\n\n// This contract relies on tons of immutable state variables to\n// perform efficient lookup, without resorting to storage reads.\n// solhint-disable max-states-count\n\ncontract CWPTradingStrategy is IPairTradingStrategy, StrategyFee, WeightedProduct {\n    using SafeCast for uint256;\n    using FixedPoint for uint128;\n\n    uint8 public constant MIN_TOKENS = 2;\n    uint8 public constant MAX_TOKENS = 16;\n    uint8 public constant MIN_WEIGHT = 1;\n\n    uint256 private immutable _swapFee;\n    uint256 private immutable _totalTokens;\n\n    IERC20 private immutable _token0;\n    IERC20 private immutable _token1;\n    IERC20 private immutable _token2;\n    IERC20 private immutable _token3;\n    IERC20 private immutable _token4;\n    IERC20 private immutable _token5;\n    IERC20 private immutable _token6;\n    IERC20 private immutable _token7;\n    IERC20 private immutable _token8;\n    IERC20 private immutable _token9;\n    IERC20 private immutable _token10;\n    IERC20 private immutable _token11;\n    IERC20 private immutable _token12;\n    IERC20 private immutable _token13;\n    IERC20 private immutable _token14;\n    IERC20 private immutable _token15;\n\n    uint256 private immutable _weight0;\n    uint256 private immutable _weight1;\n    uint256 private immutable _weight2;\n    uint256 private immutable _weight3;\n    uint256 private immutable _weight4;\n    uint256 private immutable _weight5;\n    uint256 private immutable _weight6;\n    uint256 private immutable _weight7;\n    uint256 private immutable _weight8;\n    uint256 private immutable _weight9;\n    uint256 private immutable _weight10;\n    uint256 private immutable _weight11;\n    uint256 private immutable _weight12;\n    uint256 private immutable _weight13;\n    uint256 private immutable _weight14;\n    uint256 private immutable _weight15;\n\n    constructor(\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        uint256 swapFee\n    ) {\n        require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\n        require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\n        _swapFee = swapFee;\n\n        require(tokens.length >= MIN_TOKENS, \"ERR_MIN_TOKENS\");\n        require(tokens.length <= MAX_TOKENS, \"ERR_MAX_TOKENS\");\n        require(tokens.length == weights.length, \"ERR_WEIGHTS_LIST\");\n        for (uint8 i = 0; i < tokens.length; i++) {\n            require(weights[i] >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\n        }\n\n        uint256 totalTokens = tokens.length;\n\n        //This is because immutable variables cannot be initialized inside an if statement or on another function.\n        _token0 = totalTokens > 0 ? tokens[0] : IERC20(0);\n        _token1 = totalTokens > 1 ? tokens[1] : IERC20(0);\n        _token2 = totalTokens > 2 ? tokens[2] : IERC20(0);\n        _token3 = totalTokens > 3 ? tokens[3] : IERC20(0);\n        _token4 = totalTokens > 4 ? tokens[4] : IERC20(0);\n        _token5 = totalTokens > 5 ? tokens[5] : IERC20(0);\n        _token6 = totalTokens > 6 ? tokens[6] : IERC20(0);\n        _token7 = totalTokens > 7 ? tokens[7] : IERC20(0);\n        _token8 = totalTokens > 8 ? tokens[8] : IERC20(0);\n        _token9 = totalTokens > 9 ? tokens[9] : IERC20(0);\n        _token10 = totalTokens > 10 ? tokens[10] : IERC20(0);\n        _token11 = totalTokens > 11 ? tokens[11] : IERC20(0);\n        _token12 = totalTokens > 12 ? tokens[12] : IERC20(0);\n        _token13 = totalTokens > 13 ? tokens[13] : IERC20(0);\n        _token14 = totalTokens > 14 ? tokens[14] : IERC20(0);\n        _token15 = totalTokens > 15 ? tokens[15] : IERC20(0);\n\n        _weight0 = totalTokens > 0 ? weights[0] : 0;\n        _weight1 = totalTokens > 1 ? weights[1] : 0;\n        _weight2 = totalTokens > 2 ? weights[2] : 0;\n        _weight3 = totalTokens > 3 ? weights[3] : 0;\n        _weight4 = totalTokens > 4 ? weights[4] : 0;\n        _weight5 = totalTokens > 5 ? weights[5] : 0;\n        _weight6 = totalTokens > 6 ? weights[6] : 0;\n        _weight7 = totalTokens > 7 ? weights[7] : 0;\n        _weight8 = totalTokens > 8 ? weights[8] : 0;\n        _weight9 = totalTokens > 9 ? weights[9] : 0;\n        _weight10 = totalTokens > 10 ? weights[10] : 0;\n        _weight11 = totalTokens > 11 ? weights[11] : 0;\n        _weight12 = totalTokens > 12 ? weights[12] : 0;\n        _weight13 = totalTokens > 13 ? weights[13] : 0;\n        _weight14 = totalTokens > 14 ? weights[14] : 0;\n        _weight15 = totalTokens > 15 ? weights[15] : 0;\n\n        _totalTokens = totalTokens;\n    }\n\n    function getTotalTokens() external view returns (uint256) {\n        return _totalTokens;\n    }\n\n    function getWeight(IERC20 token) public view returns (uint256) {\n        require(token != IERC20(0), \"ERR_INVALID_ADDRESS\");\n        if (token == _token0) {\n            return _weight0;\n        } else if (token == _token1) {\n            return _weight1;\n        } else if (token == _token2) {\n            return _weight2;\n        } else if (token == _token3) {\n            return _weight3;\n        } else if (token == _token4) {\n            return _weight4;\n        } else if (token == _token5) {\n            return _weight5;\n        } else if (token == _token6) {\n            return _weight6;\n        } else if (token == _token7) {\n            return _weight7;\n        } else if (token == _token8) {\n            return _weight8;\n        } else if (token == _token9) {\n            return _weight9;\n        } else if (token == _token10) {\n            return _weight10;\n        } else if (token == _token11) {\n            return _weight11;\n        } else if (token == _token12) {\n            return _weight12;\n        } else if (token == _token13) {\n            return _weight13;\n        } else if (token == _token14) {\n            return _weight14;\n        } else if (token == _token15) {\n            return _weight15;\n        } else {\n            revert(\"ERR_INVALID_TOKEN\");\n        }\n    }\n\n    function quoteOutGivenIn(\n        QuoteRequestGivenIn calldata request,\n        uint128 currentBalanceTokenIn,\n        uint128 currentBalanceTokenOut\n    ) external view override returns (uint128, uint128) {\n        // Subtract fee\n        uint128 amountInFees = request.amountIn.mul128(_swapFee.toUint128());\n        uint128 adjustedIn = request.amountIn.sub128(amountInFees);\n\n        // Calculate the maximum amount that can be taken out of the pool\n        uint128 maximumAmountOut = _outGivenIn(\n            currentBalanceTokenIn,\n            getWeight(request.tokenIn),\n            currentBalanceTokenOut,\n            getWeight(request.tokenOut),\n            adjustedIn\n        );\n\n        return (maximumAmountOut, amountInFees);\n    }\n\n    function quoteInGivenOut(\n        QuoteRequestGivenOut calldata request,\n        uint128 currentBalanceTokenIn,\n        uint128 currentBalanceTokenOut\n    ) external view override returns (uint128, uint128) {\n        // Calculate the minimum amount that must be put into the pool\n        uint128 minimumAmountIn = _inGivenOut(\n            currentBalanceTokenIn,\n            getWeight(request.tokenIn),\n            currentBalanceTokenOut,\n            getWeight(request.tokenOut),\n            request.amountOut\n        );\n\n        // Add fee\n        uint128 adjustedIn = minimumAmountIn.div128(FixedPoint.ONE.sub128(_swapFee.toUint128()));\n        uint128 amountInFees = adjustedIn.sub128(minimumAmountIn);\n\n        return (adjustedIn, amountInFees);\n    }\n\n    function getSwapFee() external view override returns (uint256) {\n        return _swapFee;\n    }\n}\n"
    },
    "contracts/strategies/lib/WeightedProduct.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nimport \"../../math/FixedPoint.sol\";\n\n// This is a contract to emulate file-level functions. Convert to a library\n// after the migration to solc v0.7.1.\n\ncontract WeightedProduct {\n    using SafeCast for uint256;\n    using FixedPoint for uint256;\n    using FixedPoint for uint128;\n\n    // Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the\n    // current balances and weights.\n    function _outGivenIn(\n        uint128 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint128 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint128 tokenAmountIn\n    ) internal pure returns (uint128) {\n        /**********************************************************************************************\n        // outGivenIn                                                                                //\n        // aO = tokenAmountOut                                                                       //\n        // bO = tokenBalanceOut                                                                      //\n        // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n        // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n        // wI = tokenWeightIn               \\      \\       ( bI + aI )         /              /      //\n        // wO = tokenWeightOut                                                                       //\n        **********************************************************************************************/\n\n        uint256 quotient = tokenBalanceIn.div(tokenBalanceIn.add(tokenAmountIn));\n        uint256 weightRatio = tokenWeightIn.div(tokenWeightOut);\n\n        uint256 ratio = FixedPoint.ONE.sub(quotient.pow(weightRatio));\n\n        return tokenBalanceOut.mul(ratio).toUint128();\n    }\n\n    // Computes how many tokens must be sent to a pool in order to take `tokenAmountOut`, given the\n    // current balances and weights.\n    function _inGivenOut(\n        uint128 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint128 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint128 tokenAmountOut\n    ) internal pure returns (uint128) {\n        /**********************************************************************************************\n        // inGivenOut                                                                                //\n        // aO = tokenAmountOut                                                                       //\n        // bO = tokenBalanceOut                                                                      //\n        // bI = tokenBalanceIn              /  /            bO             \\    (wO / wI)      \\     //\n        // aI = tokenAmountIn    aI = bI * |  | --------------------------  | ^            - 1  |    //\n        // wI = tokenWeightIn               \\  \\       ( bO - aO )         /                   /     //\n        // wO = tokenWeightOut                                                                       //\n        **********************************************************************************************/\n\n        uint256 quotient = tokenBalanceOut.div(tokenBalanceOut.sub(tokenAmountOut));\n        uint256 weightRatio = tokenWeightOut.div(tokenWeightIn);\n\n        uint256 ratio = quotient.pow(weightRatio).sub(FixedPoint.ONE);\n\n        return tokenBalanceIn.mul(ratio).toUint128();\n    }\n}\n"
    },
    "contracts/strategies/factories/CWPFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"../../vendor/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../CWPTradingStrategy.sol\";\n\ncontract CWPFactory {\n    using Address for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: Move set getters to a base factory contract\n    EnumerableSet.AddressSet private _weightedProdStrategies;\n\n    event StrategyCreated(address indexed strategy);\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() {}\n\n    function getTotalStrategies() external view returns (uint256) {\n        return _weightedProdStrategies.length();\n    }\n\n    function getStrategies(uint256 start, uint256 end) external view returns (address[] memory) {\n        require((end >= start) && (end - start) <= _weightedProdStrategies.length(), \"Bad indices\");\n\n        address[] memory strategy = new address[](end - start);\n        for (uint256 i = 0; i < strategy.length; ++i) {\n            strategy[i] = _weightedProdStrategies.at(i + start);\n        }\n\n        return strategy;\n    }\n\n    function create(\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        uint256 swapFee\n    ) external returns (address) {\n        bytes memory creationCode = abi.encodePacked(\n            type(CWPTradingStrategy).creationCode,\n            abi.encode(tokens, weights, swapFee)\n        );\n\n        address expectedStrategy = Create2.computeAddress(0, keccak256(creationCode));\n\n        if (expectedStrategy.isContract()) {\n            return expectedStrategy;\n        } else {\n            address strategy = Create2.deploy(0, 0, creationCode);\n            assert(strategy == expectedStrategy);\n\n            _weightedProdStrategies.add(strategy);\n            emit StrategyCreated(strategy);\n\n            return strategy;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/test/MockFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../math/FixedPoint.sol\";\n\nimport \"../vault/IVault.sol\";\nimport \"../vault/IFlashLoanReceiver.sol\";\n\ncontract MockFlashLoanReceiver is Ownable, IFlashLoanReceiver {\n    using FixedPoint for uint256;\n    IVault public vault;\n    bool public failExecution = false;\n\n    constructor(address _vault) public Ownable() {\n        vault = IVault(_vault);\n    }\n\n    receive() external payable {}\n\n    function setFailExecutionTransfer(bool _fail) public {\n        failExecution = _fail;\n    }\n\n    /**\n        This function is called after your contract has received the flash loaned amount\n     */\n    function executeOperation(\n        address _token,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params\n    ) external override {\n        require(IERC20(_token).balanceOf(address(this)) >= _amount, \"Invalid balance, was the flashLoan successful?\");\n\n        if (failExecution) {\n            return;\n        }\n        //\n        // Logic goes here.\n        //\n\n        uint256 totalDebt = _amount.add(_fee);\n        IERC20(_token).transfer(address(vault), totalDebt);\n    }\n\n    /**\n        Flash loan 1000000000000000000 wei (1 ether) worth of `_asset`\n     */\n    function flashloan(address _asset) public onlyOwner {\n        bytes memory data = \"\";\n        uint256 amount = 10**20; // 100 tokens\n\n        vault.flashLoan(address(this), _asset, amount, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/test/WETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract WETH9 is AccessControl {\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(MINTER_ROLE, msg.sender);\n    }\n\n    receive() external payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad, \"ERR_BALANCE\");\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    // For testing purposes\n    function mint(uint amount) public {\n        require(hasRole(MINTER_ROLE, msg.sender), \"ERR_MINTER_ROLE\");\n        balanceOf[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad, \"ERR_BALANCE\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad, \"ERR_ALLOWANCE\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}"
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract TestToken is AccessControl, ERC20 {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ERC20(name, symbol) {\n        _setupDecimals(decimals);\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(MINTER_ROLE, msg.sender);\n    }\n\n    function mint(address destinatary, uint256 amount) external {\n        require(hasRole(MINTER_ROLE, msg.sender), \"ERR_MINTER_ROLE\");\n        _mint(destinatary, amount);\n    }\n}\n"
    },
    "contracts/controllers/OwnableFixedSetPoolTokenizer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./FixedSetPoolTokenizer.sol\";\n\n// Initial implementation implements a simple, pass-through sole proprietorship model\n// for pool governance\ncontract OwnableFixedSetPoolTokenizer is FixedSetPoolTokenizer, Ownable {\n    constructor(\n        IVault _vault,\n        address strategy,\n        IVault.StrategyType strategyType,\n        uint256 initialBPT,\n        IERC20[] memory tokens,\n        uint128[] memory amounts,\n        address from\n    ) FixedSetPoolTokenizer(_vault, strategy, strategyType, initialBPT, tokens, amounts, from) Ownable() {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function changePoolController(address controller) public onlyOwner {\n        vault.setPoolController(poolId, controller);\n    }\n\n    function setInvestablePercentage(IERC20 token, uint128 percentage) public onlyOwner {\n        vault.setInvestablePercentage(poolId, token, percentage);\n    }\n\n    function authorizePoolInvestmentManager(IERC20 token, address investmentManager) public onlyOwner {\n        vault.authorizePoolInvestmentManager(poolId, token, investmentManager);\n    }\n}\n"
    },
    "contracts/controllers/FixedSetPoolTokenizer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../vault/IVault.sol\";\nimport \"../math/FixedPoint.sol\";\n\nimport \"./BToken.sol\";\n\ncontract FixedSetPoolTokenizer is BToken, ReentrancyGuard {\n    using FixedPoint for uint128;\n    using FixedPoint for uint256;\n    using SafeCast for uint256;\n\n    IVault public immutable vault;\n    bytes32 public immutable poolId;\n\n    constructor(\n        IVault _vault,\n        address strategy,\n        IVault.StrategyType strategyType,\n        uint256 initialBPT,\n        IERC20[] memory tokens,\n        uint128[] memory amounts,\n        address from\n    ) {\n        bytes32 _poolId = _vault.newPool(strategy, strategyType);\n        _vault.addLiquidity(_poolId, from, tokens, amounts, amounts);\n\n        _mintPoolShare(initialBPT);\n        _pushPoolShare(from, initialBPT);\n\n        // Set immutable state variables - these cannot be read from during construction\n        vault = _vault;\n        poolId = _poolId;\n    }\n\n    // Joining a pool\n    // poolAmountOut - how much bpt the user expects to get\n    // maxAmountsIn - the max amounts of each token the user is willing to add to the vault\n    // The set of tokens is not specified because it is read from the Vault - and remains immutable that way.\n    function joinPool(\n        uint256 poolAmountOut,\n        uint128[] calldata maxAmountsIn,\n        bool transferTokens,\n        address beneficiary\n    ) external nonReentrant {\n        uint256 poolTotal = totalSupply();\n        uint128 ratio = poolAmountOut.div(poolTotal).toUint128();\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        IERC20[] memory tokens = vault.getPoolTokens(poolId);\n        uint128[] memory balances = vault.getPoolTokenBalances(poolId, tokens);\n\n        require(maxAmountsIn.length == tokens.length, \"Tokens and amounts length mismatch\");\n\n        uint128[] memory amountsIn = new uint128[](tokens.length);\n        uint128[] memory amountsToTransfer = new uint128[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            amountsIn[i] = balances[i].mul128(ratio);\n            require(amountsIn[i] <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\n\n            if (transferTokens) {\n                amountsToTransfer[i] = amountsIn[i];\n            } else {\n                // This leads into user balance withdrawals\n                amountsToTransfer[i] = 0;\n            }\n        }\n\n        vault.addLiquidity(poolId, msg.sender, tokens, amountsIn, amountsToTransfer);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(beneficiary, poolAmountOut);\n    }\n\n    function exitPool(\n        uint256 poolAmountIn,\n        uint256[] calldata minAmountsOut,\n        bool withdrawTokens,\n        address beneficiary\n    ) external nonReentrant {\n        uint256 poolTotal = totalSupply();\n        uint128 ratio = poolAmountIn.div(poolTotal).toUint128();\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        IERC20[] memory tokens = vault.getPoolTokens(poolId);\n        uint128[] memory balances = vault.getPoolTokenBalances(poolId, tokens);\n\n        require(minAmountsOut.length == tokens.length, \"Tokens and amounts length mismatch\");\n\n        uint128[] memory amountsOut = new uint128[](tokens.length);\n        uint128[] memory amountsToTransfer = new uint128[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            amountsOut[i] = balances[i].mul128(ratio);\n            require(amountsOut[i] >= minAmountsOut[i], \"NOT EXITING ENOUGH\");\n\n            if (withdrawTokens) {\n                amountsToTransfer[i] = amountsOut[i];\n            } else {\n                // This leads into user balance deposits\n                amountsToTransfer[i] = 0;\n            }\n        }\n\n        vault.removeLiquidity(poolId, beneficiary, tokens, amountsOut, amountsToTransfer);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(poolAmountIn);\n    }\n\n    function _pullPoolShare(address from, uint256 amount) internal {\n        _pull(from, amount);\n    }\n\n    function _pushPoolShare(address to, uint256 amount) internal {\n        _push(to, amount);\n    }\n\n    function _mintPoolShare(uint256 amount) internal {\n        _mint(amount);\n    }\n\n    function _burnPoolShare(uint256 amount) internal {\n        _burn(amount);\n    }\n}\n"
    },
    "contracts/controllers/BToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// Highly opinionated token implementation\n// * It includes functions to increase and decrease allowance as a workaround\n//   for the well-known issue with 'approve':\n//   https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n// * It allows for 'infinite allowance', where an allowance of 0xff..ff is not\n//   decreased by calls to transferFrom\n// * It lets a token holder use 'transferFrom' to send their own tokens,\n//   without first setting allowance\n// * It emits 'Approval' events whenever allowance is changed by 'transferFrom'\nabstract contract BTokenBase is IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) internal _balance;\n    mapping(address => mapping(address => uint256)) internal _allowance;\n    uint256 internal _totalSupply;\n\n    function _mint(uint256 amt) internal {\n        _balance[address(this)] = _balance[address(this)].add(amt);\n        _totalSupply = _totalSupply.add(amt);\n\n        emit Transfer(address(0), address(this), amt);\n    }\n\n    function _burn(uint256 amt) internal {\n        _balance[address(this)] = _balance[address(this)].sub(amt, \"ERR_INSUFFICIENT_BAL\");\n        _totalSupply = _totalSupply.sub(amt);\n\n        emit Transfer(address(this), address(0), amt);\n    }\n\n    function _move(\n        address src,\n        address dst,\n        uint256 amt\n    ) internal {\n        _balance[src] = _balance[src].sub(amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[dst] = _balance[dst].add(amt);\n\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint256 amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint256 amt) internal {\n        _move(from, address(this), amt);\n    }\n}\n\ncontract BToken is BTokenBase {\n    using SafeMath for uint256;\n\n    string private _name = \"Balancer Pool Token\";\n    string private _symbol = \"BPT\";\n    uint8 private _decimals = 18;\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function allowance(address src, address dst) external view override returns (uint256) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) external view override returns (uint256) {\n        return _balance[whom];\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint256 amt) external override returns (bool) {\n        _allowance[msg.sender][dst] = amt;\n\n        emit Approval(msg.sender, dst, amt);\n\n        return true;\n    }\n\n    function increaseApproval(address dst, uint256 amt) external returns (bool) {\n        _allowance[msg.sender][dst] = _allowance[msg.sender][dst].add(amt);\n\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n\n        return true;\n    }\n\n    function decreaseApproval(address dst, uint256 amt) external returns (bool) {\n        uint256 oldValue = _allowance[msg.sender][dst];\n\n        if (amt > oldValue) {\n            _allowance[msg.sender][dst] = 0;\n        } else {\n            _allowance[msg.sender][dst] = oldValue.sub(amt);\n        }\n\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n\n        return true;\n    }\n\n    function transfer(address dst, uint256 amt) external override returns (bool) {\n        _move(msg.sender, dst, amt);\n\n        return true;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external override returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\n\n        _move(src, dst, amt);\n\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n            _allowance[src][msg.sender] = _allowance[src][msg.sender].sub(amt);\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/controllers/OwnableFixedSetPoolTokenizerFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"../vault/IVault.sol\";\n\nimport \"./BasePoolControllerFactory.sol\";\nimport \"./OwnableFixedSetPoolTokenizer.sol\";\n\ncontract OwnableFixedSetPoolTokenizerFactory is BasePoolControllerFactory {\n    constructor(IVault _vault) BasePoolControllerFactory(_vault) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function create(\n        address strategy,\n        IVault.StrategyType strategyType,\n        uint256 initialBPT,\n        address[] memory tokens,\n        uint128[] memory amounts,\n        address owner,\n        bytes32 salt\n    ) external returns (address) {\n        address tokenizer = _create(\n            abi.encodePacked(\n                type(OwnableFixedSetPoolTokenizer).creationCode,\n                // Make the sender the `from` address\n                abi.encode(vault, strategy, strategyType, initialBPT, tokens, amounts, msg.sender)\n            ),\n            salt\n        );\n\n        OwnableFixedSetPoolTokenizer(tokenizer).transferOwnership(owner);\n        return tokenizer;\n    }\n}\n"
    },
    "contracts/controllers/FixedSetPoolTokenizerFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"../vault/IVault.sol\";\n\nimport \"./BasePoolControllerFactory.sol\";\nimport \"./FixedSetPoolTokenizer.sol\";\n\ncontract FixedSetPoolTokenizerFactory is BasePoolControllerFactory {\n    constructor(IVault _vault) BasePoolControllerFactory(_vault) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function create(\n        address strategy,\n        IVault.StrategyType strategyType,\n        uint256 initialBPT,\n        address[] memory tokens,\n        uint128[] memory amounts,\n        bytes32 salt\n    ) external returns (address) {\n        return\n            _create(\n                abi.encodePacked(\n                    type(FixedSetPoolTokenizer).creationCode,\n                    // Make the sender the `from` address\n                    abi.encode(vault, strategy, strategyType, initialBPT, tokens, amounts, msg.sender)\n                ),\n                salt\n            );\n    }\n}\n"
    },
    "contracts/test/MockTradingStrategyReentrancy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"../strategies/IPairTradingStrategy.sol\";\nimport \"../strategies/ITupleTradingStrategy.sol\";\n\nimport \"../math/FixedPoint.sol\";\n\nimport \"../vault/IVault.sol\";\n\ncontract MockTradingStrategyReentrancy is IPairTradingStrategy {\n    using FixedPoint for uint128;\n\n    IVault public vault;\n\n    constructor(IVault _vault) {\n        vault = _vault;\n    }\n\n    // IPairTradingStrategy\n    function quoteOutGivenIn(\n        ITradingStrategy.QuoteRequestGivenIn calldata request,\n        uint128,\n        uint128\n    ) external override returns (uint128, uint128) {\n        //Reenter Vault\n        IVault.SwapIn[] memory swaps = new IVault.SwapIn[](0);\n        IERC20[] memory tokens = new IERC20[](0);\n        vault.batchSwapGivenIn(\n            swaps,\n            tokens,\n            IVault.FundManagement({\n                sender: request.from,\n                recipient: request.to,\n                withdrawFromUserBalance: false,\n                depositToUserBalance: false\n            })\n        );\n        return (request.amountIn, 0);\n    }\n\n    function quoteInGivenOut(\n        ITradingStrategy.QuoteRequestGivenOut calldata request,\n        uint128,\n        uint128\n    ) external view override returns (uint128, uint128) {\n        return (request.amountOut, 0);\n    }\n}\n"
    },
    "contracts/test/MockTradingStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"../strategies/IPairTradingStrategy.sol\";\nimport \"../strategies/ITupleTradingStrategy.sol\";\n\nimport \"../math/FixedPoint.sol\";\n\ncontract MockTradingStrategy is IPairTradingStrategy, ITupleTradingStrategy {\n    using FixedPoint for uint128;\n\n    // Amounts in are multiplied by the multiplier, amounts out divided by it\n    uint128 private _multiplier = FixedPoint.ONE;\n\n    function setMultiplier(uint128 newMultiplier) external {\n        _multiplier = newMultiplier;\n    }\n\n    // IPairTradingStrategy\n    function quoteOutGivenIn(\n        ITradingStrategy.QuoteRequestGivenIn calldata request,\n        uint128,\n        uint128\n    ) external view override returns (uint128, uint128) {\n        return (request.amountIn.mul128(_multiplier), 0);\n    }\n\n    function quoteInGivenOut(\n        ITradingStrategy.QuoteRequestGivenOut calldata request,\n        uint128,\n        uint128\n    ) external view override returns (uint128, uint128) {\n        uint128 amountIn = request.amountOut.div128(_multiplier);\n        return (amountIn, 0);\n    }\n\n    // ITupleTradingStrategy\n    function quoteOutGivenIn(\n        ITradingStrategy.QuoteRequestGivenIn calldata request,\n        uint128[] calldata,\n        uint256,\n        uint256\n    ) external view override returns (uint128, uint128) {\n        return (request.amountIn.mul128(_multiplier), 0);\n    }\n\n    function quoteInGivenOut(\n        ITradingStrategy.QuoteRequestGivenOut calldata request,\n        uint128[] calldata,\n        uint256,\n        uint256\n    ) external view override returns (uint128, uint128) {\n        uint128 amountIn = request.amountOut.div128(_multiplier);\n        return (amountIn, 0);\n    }\n}\n"
    },
    "contracts/scripts/ITradeScript.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\n\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nimport \"../math/FixedPoint.sol\";\n\nimport \"../vault/IVault.sol\";\n\ninterface ITradeScript {\n    struct OverallInfoIn {\n        IERC20 overallTokenIn;\n        IERC20 overallTokenOut;\n        uint128 maxAmountIn;\n        uint128 minAmountOut;\n    }\n\n    function swapExactAmountIn(\n        OverallInfoIn memory info,\n        IVault.SwapIn[] memory swaps,\n        IERC20[] memory tokens,\n        bool withdrawTokens\n    ) external;\n}\n"
    },
    "contracts/scripts/TradeScript.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\n\npragma solidity ^0.7.1;\n\nimport \"hardhat/console.sol\";\n\nimport \"./ITradeScript.sol\";\n\ncontract TradeScript is ITradeScript {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPoint for uint256;\n    using FixedPoint for int256;\n    using FixedPoint for uint128;\n\n    IVault private immutable _vault;\n\n    constructor(IVault vault) {\n        _vault = vault;\n    }\n\n    function swapExactAmountIn(\n        OverallInfoIn memory info,\n        IVault.SwapIn[] memory swaps,\n        IERC20[] memory tokens,\n        bool withdrawTokens\n    ) public override {\n        int256[] memory vaultDeltas = _vault.batchSwapGivenIn(\n            swaps,\n            tokens,\n            IVault.FundManagement({\n                sender: msg.sender,\n                recipient: msg.sender,\n                withdrawFromUserBalance: false,\n                depositToUserBalance: !withdrawTokens\n            })\n        );\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            if (tokens[i] == info.overallTokenIn) {\n                require(vaultDeltas[i] <= info.maxAmountIn, \"Excessive amount in\");\n            } else if (tokens[i] == info.overallTokenOut) {\n                require(vaultDeltas[i].abs() >= info.minAmountOut, \"Not enough tokens out\");\n            } else {\n                require(vaultDeltas[i] == 0, \"Intermediate non-zero balance\");\n            }\n        }\n    }\n}\n"
    },
    "contracts/investmentManagers/AaveDaiInvestmentManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nimport \"../vault/IVault.sol\";\nimport \"../investmentManagers/InvestmentManager.sol\";\nimport \"../math/FixedPoint.sol\";\n\ninterface IAToken {\n    function redeem(uint256 amount) external;\n}\n\ninterface ILendingPool {\n    function deposit(\n        address reserveAddress,\n        uint256 amount,\n        uint256 referralCode\n    ) external;\n}\n\n// solhint-disable no-empty-blocks\n// solhint-disable var-name-mixedcase\n\ncontract AaveDaiInvestmentManager is InvestmentManager {\n    using FixedPoint for uint128;\n    using SafeCast for uint256;\n\n    constructor(IVault vault, address token) InvestmentManager(vault, token) {}\n\n    // Addresses subject to change\n    // https://docs.aave.com/developers/deployed-contracts/deployed-contract-instances\n    address internal constant _LENDING_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n    address internal constant _LENDING_POOL_ADDRESS = 0x398eC7346DcD622eDc5ae82352F02bE94C62d119;\n    address internal constant _RESERVE_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // for Dai\n    address internal constant _ATOKEN_ADDRESS = 0xfC1E690f61EFd961294b3e1Ce3313fBD8aa4f85d; // For aDai\n\n    function initialize() public override {\n        // grant allowance to vault\n\n        uint256 MAX_INT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        _token.approve(address(_vault), MAX_INT);\n        _token.approve(address(_LENDING_POOL_CORE), MAX_INT);\n    }\n\n    // transfers capital out, for invesment\n    // TODO restrict\n    function sow(uint128 amount) public {\n        cash -= amount;\n\n        uint256 referralCode = 0;\n        ILendingPool(_LENDING_POOL_ADDRESS).deposit(_RESERVE_ADDRESS, amount, referralCode);\n    }\n\n    // calls capital back in from investments\n    // TODO restrict\n    function reap(uint128 amount) public {\n        IAToken(_ATOKEN_ADDRESS).redeem(amount);\n\n        cash += amount;\n    }\n}\n"
    },
    "contracts/strategies/factories/FlattenedFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"../../vendor/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../FlattenedTradingStrategy.sol\";\n\ncontract FlattenedFactory {\n    using Address for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // TODO: Move set getters to a base factory contract\n    EnumerableSet.AddressSet private _flattenedStrategies;\n\n    function getTotalStrategies() external view returns (uint256) {\n        return _flattenedStrategies.length();\n    }\n\n    function getStrategies(uint256 start, uint256 end) external view returns (address[] memory) {\n        require((end >= start) && (end - start) <= _flattenedStrategies.length(), \"Bad indices\");\n\n        address[] memory strategy = new address[](end - start);\n        for (uint256 i = 0; i < strategy.length; ++i) {\n            strategy[i] = _flattenedStrategies.at(i + start);\n        }\n\n        return strategy;\n    }\n\n    event StrategyCreated(address indexed strategy);\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() {}\n\n    function create(uint128 amp, uint256 swapFee) external returns (address) {\n        bytes memory creationCode = abi.encodePacked(\n            type(FlattenedTradingStrategy).creationCode,\n            abi.encode(amp, swapFee)\n        );\n\n        address expectedStrategy = Create2.computeAddress(0, keccak256(creationCode));\n\n        if (expectedStrategy.isContract()) {\n            return expectedStrategy;\n        } else {\n            address strategy = Create2.deploy(0, 0, creationCode);\n            assert(strategy == expectedStrategy);\n\n            _flattenedStrategies.add(strategy);\n            emit StrategyCreated(strategy);\n\n            return strategy;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 0
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}